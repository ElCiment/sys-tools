"""
Service de gestion r√©seau
G√®re les op√©rations r√©seau: v√©rification de ports, r√©cup√©ration de mots de passe WiFi, etc.
"""
import socket
import subprocess
import re
import unicodedata
import threading
from utils.system_utils import is_admin, relaunch_as_admin


def check_tcp_port(host, port, log_fn):
    """
    V√©rifie si un port TCP est accessible depuis l'EXT√âRIEUR (internet)
    Utilise plusieurs services de v√©rification de port pour plus de fiabilit√©
    
    Args:
        host (str): Adresse de l'h√¥te (ignor√©, utilise l'IP publique)
        port (int): Num√©ro de port
        log_fn (callable): Fonction de logging
    """
    log_fn(f"üîé V√©rification de l'accessibilit√© EXTERNE du port {port}...")
    log_fn("‚è≥ Test depuis l'ext√©rieur (internet)...")
    
    try:
        import urllib.request
        import urllib.parse
        import json
        
        # R√©cup√©rer l'IP publique d'abord
        log_fn("üì° R√©cup√©ration de votre IP publique...")
        try:
            ip_response = urllib.request.urlopen('https://api.ipify.org?format=json', timeout=5)
            public_ip = json.loads(ip_response.read().decode())['ip']
        except:
            # Backup API
            ip_response = urllib.request.urlopen('https://api.my-ip.io/ip', timeout=5)
            public_ip = ip_response.read().decode().strip()
        
        log_fn(f"üåê Votre IP publique: {public_ip}")
        
        # V√©rifier le port avec API externe (seule m√©thode fiable)
        log_fn(f"üîç Test du port {port} depuis l'ext√©rieur...")
        
        is_open = None
        error_msg = ""
        
        # M√©thode 1: API portchecker.co
        try:
            log_fn("  ‚Üí Test via portchecker.co...")
            check_url = f'https://api.portchecker.co/check?host={public_ip}&port={port}'
            req = urllib.request.Request(check_url, headers={
                'User-Agent': 'Mozilla/5.0',
                'Accept': 'application/json'
            })
            response = urllib.request.urlopen(req, timeout=20)
            result = json.loads(response.read().decode('utf-8'))
            is_open = result.get('open', False) or result.get('status', '').lower() == 'open'
            log_fn(f"  ‚úì R√©ponse API: {result}")
        except Exception as e:
            log_fn(f"  ‚úó Erreur API portchecker.co: {e}")
            error_msg = str(e)
            
        # M√©thode 2 (backup): API yougetsignal.com
        if is_open is None:
            try:
                log_fn("  ‚Üí Test via yougetsignal.com...")
                check_url = f'https://ports.yougetsignal.com/check-port.php'
                data = urllib.parse.urlencode({'remoteAddress': public_ip, 'portNumber': port}).encode()
                req = urllib.request.Request(check_url, data=data, headers={
                    'User-Agent': 'Mozilla/5.0',
                    'Content-Type': 'application/x-www-form-urlencoded'
                })
                response = urllib.request.urlopen(req, timeout=20)
                text = response.read().decode('utf-8').lower()
                if 'open' in text:
                    is_open = True
                    log_fn(f"  ‚úì Port d√©tect√© ouvert")
                elif 'closed' in text:
                    is_open = False
                    log_fn(f"  ‚úì Port d√©tect√© ferm√©")
            except Exception as e:
                log_fn(f"  ‚úó Erreur API yougetsignal: {e}")
                if not error_msg:
                    error_msg = str(e)
        
        # Afficher le r√©sultat final
        log_fn("")
        if is_open is True:
            log_fn(f"‚úÖ Port {port} est OUVERT et accessible depuis l'ext√©rieur (internet)")
            log_fn(f"   Vous pouvez vous connecter via {public_ip}:{port}")
        elif is_open is False:
            log_fn(f"‚ùå Port {port} est FERM√â ou inaccessible depuis l'ext√©rieur")
            log_fn(f"   Le port n'est pas ouvert dans votre routeur/firewall")
            log_fn(f"   Pour l'ouvrir: configurez le NAT/Port Forwarding dans votre routeur")
        else:
            log_fn(f"‚ö†Ô∏è  Impossible de v√©rifier le port {port}")
            log_fn(f"   Erreur: {error_msg}")
            log_fn(f"   V√©rifiez manuellement sur: https://canyouseeme.org")
        
    except Exception as e:
        log_fn(f"‚ùå Erreur g√©n√©rale: {e}")
        log_fn(f"‚ö†Ô∏è  V√©rifiez manuellement le port sur: https://canyouseeme.org")


def _decode_bytes(b):
    """
    Tente de d√©coder des bytes avec diff√©rents encodages
    
    Args:
        b (bytes): Donn√©es √† d√©coder
    
    Returns:
        str: Cha√Æne d√©cod√©e
    """
    for enc in ("cp1252", "cp850", "utf-8", "latin-1"):
        try:
            return b.decode(enc)
        except Exception:
            continue
    return b.decode("utf-8", errors="replace")


def _normalize_text(s):
    """
    Normalise le texte pour g√©rer les encodages corrompus de Windows
    
    Args:
        s (str): Texte √† normaliser
    
    Returns:
        str: Texte normalis√©
    """
    s = unicodedata.normalize("NFKC", s)
    
    replacements = {
        "√É¬©": "√©", "√É¬®": "√®", "√É¬™": "√™", "√É¬´": "√´", "√É ": "√†",
        "√É¬¢": "√¢", "√É¬¥": "√¥", "√É¬π": "√π", "√É¬ª": "√ª", "√É¬ß": "√ß",
        "√Ç": "", "\u00A0": " "
    }
    
    for k, v in replacements.items():
        s = s.replace(k, v)
    
    s = re.sub(r'[\x00-\x08\x0b\x0c\x0e-\x1f]', '', s)
    return s


def get_wifi_passwords(log_fn):
    """
    R√©cup√®re les mots de passe WiFi sauvegard√©s
    
    Args:
        log_fn (callable): Fonction de logging
    """
    if not is_admin():
        log_fn("üîº N√©cessite les droits administrateur pour r√©cup√©rer les mots de passe WiFi")
        try:
            relaunch_as_admin()
        except Exception as e:
            log_fn(f"‚ùå Impossible de relancer en admin: {e}")
        return
    
    log_fn("‚ñ∂ R√©cup√©ration des profils WiFi et mots de passe...")
    
    try:
        proc = subprocess.run(
            ["netsh", "wlan", "show", "profiles"],
            capture_output=True, text=False, check=True
        )
        stdout = _normalize_text(_decode_bytes(proc.stdout))
        
        profiles = []
        for line in stdout.splitlines():
            m = re.search(
                r'(?:Profil\s+Tous\s+les\s+utilisateurs|All User Profile|Profil|Profile)[^:]*:\s*(.+)$',
                line.strip(), flags=re.IGNORECASE
            )
            if m:
                name = m.group(1).strip().strip('"')
                if name:
                    profiles.append(name)
        
        profiles = list(dict.fromkeys(profiles))
        
        if not profiles:
            log_fn("‚ùå Aucun profil WiFi trouv√©")
            return
        
        log_fn("----- Profils WiFi trouv√©s -----")
        for p in profiles:
            log_fn(f"üì∂ Profil: {p}")
        
        log_fn("----- Mots de passe -----")
        for profile in profiles:
            try:
                password_proc = subprocess.run(
                    ["netsh", "wlan", "show", "profile", "name=" + profile, "key=clear"],
                    capture_output=True, text=False, check=True
                )
                out = _normalize_text(_decode_bytes(password_proc.stdout))
                
                m_pwd = re.search(
                    r'(?im)(?:contenu\s*(?:de\s*la\s*)?cle|cont.*de.*la.*cle|key\s*content|contenu\s*de\s*la\s*cl[e√©])[^\:]*:\s*([^\r\n]+)',
                    out
                )
                
                pwd = m_pwd.group(1).strip() if m_pwd else "Non trouv√©"
                log_fn(f"üîë {profile}: {pwd}")
                
            except subprocess.CalledProcessError as e:
                log_fn(f"‚ùå Erreur pour {profile}: Impossible de r√©cup√©rer le mot de passe")
            except Exception as e:
                log_fn(f"‚ùå Erreur inattendue pour {profile}: {e}")
        
        log_fn("‚úÖ R√©cup√©ration termin√©e")
        
    except Exception as e:
        log_fn(f"‚ùå Erreur globale: {e}")


def get_teamviewer_id():
    """
    R√©cup√®re l'ID TeamViewer
    
    Returns:
        str: ID TeamViewer ou message d'erreur
    """
    try:
        res = subprocess.check_output(
            r'reg query "HKLM\SOFTWARE\WOW6432Node\TeamViewer" /v ClientID',
            shell=True, text=True, stderr=subprocess.DEVNULL
        )
        tv_id_raw = res.strip().split()[-1]
        return str(int(tv_id_raw, 16)) if tv_id_raw.startswith("0x") else tv_id_raw
    except Exception:
        try:
            res = subprocess.check_output(
                r'reg query "HKLM\SOFTWARE\TeamViewer" /v ClientID',
                shell=True, text=True, stderr=subprocess.DEVNULL
            )
            tv_id_raw = res.strip().split()[-1]
            return str(int(tv_id_raw, 16)) if tv_id_raw.startswith("0x") else tv_id_raw
        except Exception:
            return "Non install√© ou introuvable"


def get_anydesk_id():
    """
    R√©cup√®re l'ID AnyDesk
    
    Returns:
        str: ID AnyDesk ou message d'erreur
    """
    try:
        res = subprocess.check_output(
            r'reg query "HKLM\SOFTWARE\AnyDesk" /v "ClientID"',
            shell=True, text=True, stderr=subprocess.DEVNULL
        )
        return res.strip().split()[-1]
    except Exception:
        try:
            res = subprocess.check_output(
                r'reg query "HKLM\SOFTWARE\WOW6432Node\AnyDesk" /v "ClientID"',
                shell=True, text=True, stderr=subprocess.DEVNULL
            )
            return res.strip().split()[-1]
        except Exception:
            return "Non install√© ou introuvable"


def show_wifi_passwords(log_fn):
    """
    Affiche tous les mots de passe WiFi enregistr√©s dans la console
    
    Args:
        log_fn (callable): Fonction de logging
    """
    if not is_admin():
        log_fn("üîº N√©cessite les droits administrateur")
        try:
            relaunch_as_admin()
        except Exception as e:
            log_fn(f"‚ùå Impossible de relancer en admin: {e}")
        return
    
    def worker():
        try:
            log_fn("‚ñ∂ R√©cup√©ration des profils WiFi...")
            
            # Lister tous les profils
            profiles_result = subprocess.run(
                ["netsh", "wlan", "show", "profiles"],
                capture_output=True, text=True, encoding="utf-8", errors="ignore"
            )
            
            if profiles_result.returncode != 0:
                log_fn("‚ùå Impossible de lister les profils WiFi")
                return
            
            # Extraire les noms des profils
            profiles = []
            for line in profiles_result.stdout.splitlines():
                if "Profil Tous les utilisateurs" in line or "All User Profile" in line:
                    # Format: "    Profil Tous les utilisateurs : NomDuReseau"
                    parts = line.split(":")
                    if len(parts) >= 2:
                        profile_name = parts[1].strip()
                        profiles.append(profile_name)
            
            if not profiles:
                log_fn("‚ö†Ô∏è Aucun profil WiFi trouv√©")
                return
            
            log_fn(f"‚úÖ {len(profiles)} profil(s) WiFi trouv√©(s)")
            log_fn("=" * 60)
            
            # Pour chaque profil, afficher le mot de passe
            for profile in profiles:
                try:
                    password_result = subprocess.run(
                        ["netsh", "wlan", "show", "profile", profile, "key=clear"],
                        capture_output=True, text=True, encoding="utf-8", errors="ignore"
                    )
                    
                    password = "Non disponible"
                    for line in password_result.stdout.splitlines():
                        if "Contenu de la cl√©" in line or "Key Content" in line:
                            parts = line.split(":")
                            if len(parts) >= 2:
                                password = parts[1].strip()
                                break
                    
                    log_fn(f"üì∂ {profile}")
                    log_fn(f"   üîë Mot de passe: {password}")
                    log_fn("")
                    
                except Exception as e:
                    log_fn(f"‚ùå Erreur pour {profile}: {e}")
            
            log_fn("=" * 60)
            log_fn("‚úÖ R√©cup√©ration termin√©e")
            
        except Exception as e:
            log_fn(f"‚ùå Erreur g√©n√©rale: {e}")
    
    threading.Thread(target=worker, daemon=True).start()
