ok le "verifier port tcp" ne semble pas faire ce que je veux il me dit que le port 40000 est ouvert qusn l'aplication qui lutilise fonctionne .. mais je nai pas ouvert ce port dasn le routeur .. quand je regarde avec canyouseeme.org ca medit qu'il est fermer je veux que ca verifie si le port est accesilble a l'exterieur

la page adresse ip ne fonctionne toujorus pas comme il faut .. ce nest pas tout les champs qui sont prerempli avec les donner actuel .. ca me dit aussi que mon interface est static quand elle est dhcp

dans "infos systems' il me manquerasi 2 information soit le nom du proceseur (i7 9600k , ryzen 5600x etc...)  et le type de ram utiliser (ddr3 3800mhz .. ddr4 etc...)

jai egalement modifier mon main_window.py .. je te le fourni comme ca les nouvelle modif que tu va me donner doivent incluire les mienne deja faite


"""
Fen√™tre principale de l'application
Interface utilisateur principale avec menu lat√©ral et console int√©gr√©e
"""
import os
import sys
import time
import threading
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk
import webbrowser
import subprocess
import re
import psutil

from utils.system_utils import get_base_path, is_admin, relaunch_as_admin
from services.printer_service import build_message, send_tcp, send_serial, get_serial_ports
from services.windows_service import (
    tweak_taskbar, restore_context_menu, uninstall_kb5064081,
    disable_windows_notifications, apply_wallpaper, rename_computer, add_windows_user,
    create_veloce_shortcuts, restore_context_menu_win11
)
from services.network_service import check_tcp_port, get_wifi_passwords, get_teamviewer_id, get_anydesk_id, show_wifi_passwords


class ToolsApp(ctk.CTk):
    """Fen√™tre principale de l'application Outils - Syst√®me"""
    
    def __init__(self):
        super().__init__()
        
        self.title("Outils - Syst√®me")
        base_path = get_base_path()
        
        # Ic√¥ne de l'application
        icon_path = os.path.join(base_path, "mainicon.ico")
        if os.path.exists(icon_path):
            try:
                self.iconbitmap(icon_path)
            except Exception as e:
                print(f"Impossible de charger l'ic√¥ne: {e}")
        
        # Configuration de la grille
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(1, weight=1)
        
        # Initialisation des variables
        self._init_variables()
        
        # Cr√©ation de l'interface
        self._create_menu_bar()
        self._create_header()
        self._create_left_menu()
        self._create_main_area()
        
        # Log initial
        self.log(f"Application d√©marr√©e. Admin: {'Oui' if is_admin() else 'Non'}")
        
        # Maximiser la fen√™tre apr√®s la cr√©ation compl√®te de l'interface
        self.after(100, lambda: self.state("zoomed"))
        
        # R√©cup√©ration des IDs en arri√®re-plan
        threading.Thread(target=self._update_remote_ids, daemon=True).start()
    
    def _init_variables(self):
        """Initialise les variables de l'application"""
        self.print_text_var = ctk.StringVar(value="------ Test d'impression ------")
        self.mode_var = tk.StringVar(value="tcp")
        self.com_var = tk.StringVar(value="")
        self.repeat_var = tk.StringVar(value="1")
        self.lines_var = tk.StringVar(value="20")
        self.ip_var = tk.StringVar(value="192.168.192.168")
        self.port_var = tk.StringVar(value="9100")
        self.baud_var = tk.StringVar(value="115200")
        self.shortcut_folder_var = tk.StringVar(value=r"C:\veloce")
        self.check_host_var = tk.StringVar(value="127.0.0.1")
        self.check_port_var = tk.StringVar(value="40000")
        self.wallpaper_var = tk.StringVar(value="wallpaper-kpi.jpg")
        self.pc_name_var = tk.StringVar(value=os.environ.get("COMPUTERNAME", ""))
    
    def _create_menu_bar(self):
        """Cr√©e la barre de menu"""
        menubar = tk.Menu(self, tearoff=0, font=("Segoe UI", 12))
        
        # Menu Fichier
        fichier_menu = tk.Menu(menubar, tearoff=0, font=("Segoe UI", 12))
        fichier_menu.add_separator()
        fichier_menu.add_command(label="‚ùå Quitter", command=self.quit)
        menubar.add_cascade(label="Fichier", menu=fichier_menu)
        
        # Menu Outils
        outils_menu = tk.Menu(menubar, tearoff=0, font=("Segoe UI", 12))
        outils_menu.add_command(label="‚öôÔ∏è Panneau de configuration", command=lambda: os.system("control"))
        outils_menu.add_command(label="üñ•Ô∏è G√©rer l'ordinateur", command=lambda: os.system("compmgmt.msc"))
        outils_menu.add_command(label="üìä Gestionnaire des t√¢ches", command=lambda: os.system("taskmgr"))
        outils_menu.add_separator()
        outils_menu.add_command(label="üß© Programmes et fonctionnalit√©s", command=lambda: os.system("appwiz.cpl"))
        outils_menu.add_command(label="üîÑ Windows Update", command=lambda: os.system("control /name Microsoft.WindowsUpdate"))
        outils_menu.add_command(label="üåê Connexions r√©seau", command=lambda: os.system("ncpa.cpl"))
        menubar.add_cascade(label="Outils", menu=outils_menu)
        
        # Menu Syst√®me
        system_menu = tk.Menu(menubar, tearoff=0, font=("Segoe UI", 12))
        system_menu.add_command(label="üìÅ Explorateur", command=lambda: os.system("explorer"))
        system_menu.add_command(label="üßæ Informations syst√®me", command=lambda: os.system("msinfo32"))
        system_menu.add_command(label="‚ö° PowerShell", command=lambda: os.system("powershell"))
        system_menu.add_separator()
        system_menu.add_command(label="üß† Registre Windows", command=lambda: os.system("regedit"))
        system_menu.add_command(label="üß∞ Services Windows", command=lambda: os.system("services.msc"))
        system_menu.add_command(label="üöÄ Configuration du syst√®me", command=lambda: os.system("msconfig"))
        system_menu.add_separator()
        system_menu.add_command(label="üóÇÔ∏è Dossier D√©marrage", command=lambda: os.system("explorer shell:startup"))
        menubar.add_cascade(label="Syst√®me", menu=system_menu)
        
        # Menu Aide
        aide_menu = tk.Menu(menubar, tearoff=0, font=("Segoe UI", 12))
        aide_menu.add_command(label="üìÑ Release Notes", command=self.show_release_notes)
        aide_menu.add_command(label="üåê T√©l√©chargements", command=lambda: webbrowser.open("https://kpi-tech.ca/launcher/telechargements.html"))
        menubar.add_cascade(label="Aide", menu=aide_menu)
        
        self.config(menu=menubar)
    
    def _create_header(self):
        """Cr√©e l'en-t√™te de l'application"""
        header = ctk.CTkFrame(self, fg_color="transparent")
        header.grid(row=0, column=0, columnspan=4, sticky="nsew", padx=12, pady=(12, 4))
        header.grid_columnconfigure(1, weight=1)
        
        # Logo
        base_path = get_base_path()
        logo_path = os.path.join(base_path, "assets", "images", "mainlogo.png")
        if os.path.exists(logo_path):
            try:
                logo_image = Image.open(logo_path).resize((100, 100), Image.Resampling.LANCZOS)
                self.logo_photo = ImageTk.PhotoImage(logo_image)
                logo_label = ctk.CTkLabel(header, image=self.logo_photo, text="")
                logo_label.grid(row=0, column=0, rowspan=3, sticky="w", padx=(0, 10))
            except Exception as e:
                print(f"Impossible de charger le logo: {e}")
        
        # Titre et version
        title = ctk.CTkLabel(header, text="Outils - Syst√®me", font=ctk.CTkFont(size=20, weight="bold"))
        title.grid(row=0, column=1, sticky="w", pady=(4, 0))
        
        version = ctk.CTkLabel(header, text="Version 1.6.3", font=ctk.CTkFont(size=12))
        version.grid(row=1, column=1, sticky="w")
        
        # TeamViewer et AnyDesk IDs (affich√©s en permanence)
        self.tv_label = ctk.CTkLabel(header, text="TeamViewer ID: Chargement...", 
                                      font=ctk.CTkFont(size=11), text_color="gray")
        self.tv_label.grid(row=0, column=2, sticky="e", padx=(10, 0))
        
        self.ad_label = ctk.CTkLabel(header, text="AnyDesk ID: Chargement...", 
                                      font=ctk.CTkFont(size=11), text_color="gray")
        self.ad_label.grid(row=1, column=2, sticky="e", padx=(10, 0))
        
        # Bouton Effacer console
        clear_btn = ctk.CTkButton(header, text="üóëÔ∏è Effacer console", width=140,
                                   command=self.clear_console, fg_color="#c03a3a", hover_color="#e05454")
        clear_btn.grid(row=2, column=2, sticky="e", pady=(5, 0))
    
    def _create_left_menu(self):
        """Cr√©e le menu lat√©ral gauche"""
        left = ctk.CTkScrollableFrame(self, width=260, corner_radius=8)
        left.grid(row=1, column=0, sticky="nsw", padx=(12, 6), pady=8)
        
        lbl = ctk.CTkLabel(left, text="Fonctions", font=ctk.CTkFont(size=14, weight="bold"))
        lbl.pack(anchor="nw", padx=12, pady=(12, 6))
        
        # Menu items avec sections
        menu_items = [
        
            ("‚öôÔ∏è Setup", None),
            ("Auto Setup", "auto_setup"),       
        
            ("üìä Syst√®me/Windows", None),
            ("Infos Syst√®me", "show_system_info"),
            ("Activer Windows", "activate_windows"),
            ("Renommer le PC", "rename_pc"),
            ("Tweaks Windows", "tweak_windows"),
            ("G√©rer les Utilisateurs", "manage_users"),
            ("Commandes personnalis√©es", "custom_commands"), 

            
            ("üí≥ POS", None),
            ("Cr√©er raccourcis VELBO/VELSRV", "create_shortcuts"),
            
            ("üåê R√©seau", None),
            ("V√©rifier port TCP 40000", "check_port"),
            ("Voir mots de passe WiFi", "show_wifi_passwords"),
            ("Adresse IP", "ip_config"),
            
            ("üñ®Ô∏è Imprimantes", None),
            ("Test impression", "print_test"),
            

        ]
        
        for txt, key in menu_items:
            if key is None:
                # Titre de section
                lbl = ctk.CTkLabel(left, text=txt, font=ctk.CTkFont(size=12, weight="bold"))
                lbl.pack(anchor="nw", padx=12, pady=(12, 4))
                # Ligne de s√©paration
                separator = ctk.CTkFrame(left, height=1, fg_color="#555555")
                separator.pack(fill="x", padx=12, pady=(0, 8))
            else:
                b = ctk.CTkButton(
                    left, text=txt, width=220, height=44,
                    fg_color="#c03a3a", hover_color="#e05454",
                    command=lambda k=key: self.show_function(k)
                )
                b.pack(padx=12, pady=6, anchor="n")
    
    def _create_main_area(self):
        """Cr√©e la zone principale (console + options)"""
        main = ctk.CTkFrame(self)
        main.grid(row=1, column=1, sticky="nsew", padx=(6, 12), pady=8)
        main.grid_rowconfigure(1, weight=1)
        main.grid_columnconfigure(0, weight=1)
        
        # Console title
        cons_title = ctk.CTkLabel(main, text="Journal / Console", font=ctk.CTkFont(size=12, weight="bold"))
        cons_title.grid(row=0, column=0, sticky="w", padx=8, pady=(8, 2))
        
        # Console textbox
        self.log_box = ctk.CTkTextbox(main, wrap="word", font=("Courier New", 12))
        self.log_box.grid(row=1, column=0, sticky="nsew", padx=8, pady=(0, 8))
        self.log_box.configure(state="disabled")
        
        # Bottom frame pour les options dynamiques
        bottom_frame = ctk.CTkFrame(main, corner_radius=8)
        bottom_frame.grid(row=2, column=0, sticky="nsew", padx=8, pady=8)
        bottom_frame.grid_columnconfigure(0, weight=1)
        bottom_frame.grid_rowconfigure(0, weight=1)
        
        self.func_options_holder = ctk.CTkFrame(bottom_frame, fg_color="transparent")
        self.func_options_holder.pack(fill="both", expand=True, padx=8, pady=8)
    
    def log(self, message):
        """Ajoute un message au journal de la console"""
        ts = time.strftime("%Y-%m-%d %H:%M:%S")
        msg = f"[{ts}] {message}\n"
        self.log_box.configure(state="normal")
        self.log_box.insert("end", msg)
        self.log_box.see("end")
        self.log_box.configure(state="disabled")
    
    def clear_console(self):
        """Efface le contenu de la console"""
        self.log_box.configure(state="normal")
        self.log_box.delete("1.0", "end")
        self.log_box.configure(state="disabled")
        self.log("Console effac√©e")
    
    def show_function(self, func_key):
        """Affiche l'interface d'une fonction"""
        # Nettoyer l'ancien contenu
        for widget in self.func_options_holder.winfo_children():
            widget.destroy()
        
        # Appeler la fonction correspondante
        if func_key == "print_test":
            self._build_print_options(self.func_options_holder)
        elif func_key == "check_port":
            self._build_checkport_options(self.func_options_holder)
        elif func_key == "show_wifi_passwords":
            self._build_wifi_options(self.func_options_holder)
        elif func_key == "tweak_windows":
            self._build_tweak_options(self.func_options_holder)
        elif func_key == "rename_pc":
            self._build_rename_pc_options(self.func_options_holder)
        elif func_key == "activate_windows":
            self._build_activate_windows_options(self.func_options_holder)
        elif func_key == "show_system_info":
            self._show_system_info()
        elif func_key == "create_shortcuts":
            self._build_shortcuts_options(self.func_options_holder)
        elif func_key == "manage_users":
            self._build_manage_users_options(self.func_options_holder)
        elif func_key == "auto_setup":
            self.build_auto_setup_options(self.func_options_holder)
        elif func_key == "custom_commands":
            self.build_custom_commands_options(self.func_options_holder)
        elif func_key == "ip_config":
            self.build_ip_config_options(self.func_options_holder)
        else:
            self.log(f"Fonction '{func_key}' non impl√©ment√©e")
    
    def _build_print_options(self, parent):
        """Construit l'interface de test d'impression"""
        f = ctk.CTkFrame(parent)
        f.pack(fill="both", expand=True)
        
        # Mode de communication
        row_frame = ctk.CTkFrame(f, fg_color="transparent")
        row_frame.pack(anchor="nw", fill="x", pady=(4, 8))
        ctk.CTkLabel(row_frame, text="Mode de communication:").pack(side="left", padx=(4, 8))
        mode_combo = ctk.CTkOptionMenu(row_frame, values=["tcp", "com"], variable=self.mode_var, width=120)
        mode_combo.pack(side="left")
        
        # Conteneur pour TCP/COM
        self.conn_frame = ctk.CTkFrame(f)
        self.conn_frame.pack(fill="x", padx=6, pady=(6, 4))
        self.conn_frame.grid_propagate(False)
        self.conn_frame.configure(height=130)
        
        # TCP Frame
        self.tcp_frame = ctk.CTkFrame(self.conn_frame)
        self.tcp_frame.grid(row=0, column=0, sticky="nsew")
        ctk.CTkLabel(self.tcp_frame, text="Connexion TCP/IP", font=ctk.CTkFont(weight="bold")).grid(row=0, column=0, sticky="w", padx=6, pady=6)
        ctk.CTkLabel(self.tcp_frame, text="Adresse IP:").grid(row=1, column=0, sticky="w", padx=6, pady=4)
        ctk.CTkEntry(self.tcp_frame, textvariable=self.ip_var, width=220).grid(row=1, column=1, sticky="w", padx=6, pady=4)
        ctk.CTkLabel(self.tcp_frame, text="Port:").grid(row=2, column=0, sticky="w", padx=6, pady=4)
        ctk.CTkEntry(self.tcp_frame, textvariable=self.port_var, width=120).grid(row=2, column=1, sticky="w", padx=6, pady=4)
        
        # COM Frame
        self.com_frame = ctk.CTkFrame(self.conn_frame)
        self.com_frame.grid(row=0, column=0, sticky="nsew")
        ctk.CTkLabel(self.com_frame, text="Connexion S√©rie (COM)", font=ctk.CTkFont(weight="bold")).grid(row=0, column=0, sticky="w", padx=6, pady=6)
        ctk.CTkLabel(self.com_frame, text="Port COM:").grid(row=1, column=0, sticky="w", padx=6, pady=4)
        
        ports = get_serial_ports()
        self.com_option = ctk.CTkOptionMenu(self.com_frame, values=ports if ports else ["Aucun d√©tect√©"], variable=self.com_var, width=220)
        self.com_option.grid(row=1, column=1, sticky="w", padx=6, pady=4)
        
        ctk.CTkButton(self.com_frame, text="üîÑ Rafra√Æchir", width=120, command=self._refresh_com_ports).grid(row=1, column=2, padx=6, pady=4)
        
        ctk.CTkLabel(self.com_frame, text="Baudrate:").grid(row=2, column=0, sticky="w", padx=6, pady=4)
        baud_rates = ["9600", "19200", "38400", "57600", "115200"]
        self.baud_menu = ctk.CTkOptionMenu(self.com_frame, values=baud_rates, variable=self.baud_var, width=120)
        self.baud_menu.grid(row=2, column=1, sticky="w", padx=6, pady=4)
        
        # Options
        opts = ctk.CTkFrame(f, fg_color="transparent")
        opts.pack(fill="x", padx=6, pady=(10, 6))
        ctk.CTkLabel(opts, text="R√©p√©titions:").grid(row=0, column=0, padx=6, pady=6, sticky="w")
        ctk.CTkEntry(opts, textvariable=self.repeat_var, width=80).grid(row=0, column=1, padx=6, pady=6, sticky="w")
        
        ctk.CTkLabel(opts, text="Lignes par section:").grid(row=1, column=0, padx=6, pady=6, sticky="w")
        ctk.CTkEntry(opts, textvariable=self.lines_var, width=80).grid(row=1, column=1, padx=6, pady=6, sticky="w")
        
        ctk.CTkButton(opts, text="üöÄ Envoyer le test", width=160, command=self._run_print_test).grid(row=0, column=2, rowspan=2, padx=12, pady=6)
        
        # Texte √† imprimer
        text_frame = ctk.CTkFrame(f, fg_color="transparent")
        text_frame.pack(fill="x", padx=6, pady=(6, 4))
        ctk.CTkLabel(text_frame, text="Texte √† imprimer:").grid(row=0, column=0, sticky="w", padx=6, pady=4)
        ctk.CTkEntry(text_frame, textvariable=self.print_text_var, width=400).grid(row=0, column=1, sticky="w", padx=6, pady=4)
        
        # Toggle TCP/COM
        def toggle():
            if self.mode_var.get() == "tcp":
                self.com_frame.grid_remove()
                self.tcp_frame.grid()
            else:
                self.tcp_frame.grid_remove()
                self.com_frame.grid()
        
        self.mode_var.trace_add("write", lambda *_: toggle())
        toggle()
    
    def _build_checkport_options(self, parent):
        """Construit l'interface de v√©rification de port"""
        f = ctk.CTkFrame(parent)
        f.pack(fill="both", expand=True, padx=6, pady=6)
        ctk.CTkLabel(f, text="V√©rifier si le port TCP 40000 est ouvert", font=ctk.CTkFont(weight="bold")).pack(anchor="w", pady=(0, 6))
        
        row = ctk.CTkFrame(f, fg_color="transparent")
        row.pack(anchor="w", pady=(6, 8))
        ctk.CTkLabel(row, text="H√¥te:").pack(side="left")
        ctk.CTkEntry(row, textvariable=self.check_host_var, width=140).pack(side="left", padx=(4, 12))
        ctk.CTkLabel(row, text="Port:").pack(side="left")
        ctk.CTkEntry(row, textvariable=self.check_port_var, width=80).pack(side="left", padx=(4, 0))
        
        ctk.CTkButton(f, text="Tester le port", width=200, command=self._run_check_port).pack(pady=6)
    
    def _build_wifi_options(self, parent):
        """Construit l'interface de r√©cup√©ration des mots de passe WiFi"""
        f = ctk.CTkFrame(parent)
        f.pack(fill="both", expand=True, padx=6, pady=6)
        ctk.CTkLabel(f, text="Voir les mots de passe WiFi sauvegard√©s", font=ctk.CTkFont(weight="bold")).pack(anchor="w", pady=(0, 6))
        ctk.CTkLabel(f, text="R√©cup√®re tous les profils WiFi enregistr√©s et leurs mots de passe.", text_color="#a8b3c6").pack(anchor="w", pady=(0, 6))
        ctk.CTkButton(f, text="üîç R√©cup√©rer les mots de passe WiFi", width=280, command=self._run_show_wifi_passwords).pack(pady=6)
    
    def _build_tweak_options(self, parent):
        """Construit l'interface des tweaks Windows"""
        f = ctk.CTkFrame(parent)
        f.pack(fill="both", expand=True, padx=6, pady=6)
        ctk.CTkLabel(f, text="Tweaks Windows & Options", font=ctk.CTkFont(weight="bold")).pack(anchor="w", pady=(0, 6))
        
        ctk.CTkButton(f, text="Appliquer Tweaks Taskbar", width=220, fg_color="#4c84e0", hover_color="#2e62c9", command=self._run_tweak_taskbar).pack(anchor="w", pady=(0, 8))
        ctk.CTkButton(f, text="D√©sactiver notifications Windows", width=260, fg_color="#4c84e0", hover_color="#2e62c9", command=self._run_disable_notifications).pack(anchor="w", pady=(0, 8))
        ctk.CTkButton(f, text="R√©tablir Right Click Menu (Win11)", width=260, fg_color="#4c84e0", hover_color="#2e62c9", command=self._run_restore_menu).pack(anchor="w", pady=(0, 20))
        ctk.CTkButton(f, text="üß© D√©sinstaller KB5064081", width=240, fg_color="#e05454", hover_color="#c03a3a", command=self._run_uninstall_kb).pack(anchor="w", pady=(0, 20))
        
        # S√©lecteur de wallpaper
        ctk.CTkLabel(f, text="üñºÔ∏è Appliquer un fond d'√©cran:", font=ctk.CTkFont(weight="bold")).pack(anchor="w", pady=(0, 6))
        
        # D√©tecter les wallpapers disponibles
        base_path = get_base_path()
        wallpaper_dir = os.path.join(base_path, "assets", "wallpapers")
        wallpapers = []
        if os.path.exists(wallpaper_dir):
            for file in os.listdir(wallpaper_dir):
                if file.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp')):
                    wallpapers.append(file)
        
        if not wallpapers:
            wallpapers = ["wallpaper-kpi.jpg"]  # D√©faut
        
        # Variable pour le wallpaper s√©lectionn√©
        if not hasattr(self, 'selected_wallpaper_var'):
            self.selected_wallpaper_var = tk.StringVar(value=wallpapers[0] if wallpapers else "")
        
        # Frame pour le s√©lecteur
        wallpaper_frame = ctk.CTkFrame(f, fg_color="transparent")
        wallpaper_frame.pack(anchor="w", pady=(0, 8))
        
        ctk.CTkLabel(wallpaper_frame, text="Wallpaper:").pack(side="left", padx=(0, 8))
        wallpaper_menu = ctk.CTkOptionMenu(wallpaper_frame, variable=self.selected_wallpaper_var, 
                                           values=wallpapers, width=300)
        wallpaper_menu.pack(side="left", padx=(0, 8))
        
        ctk.CTkButton(wallpaper_frame, text="Appliquer", width=120, 
                      fg_color="#16a34a", hover_color="#15803d",
                      command=self._run_apply_wallpaper).pack(side="left")
    
    def _build_rename_pc_options(self, parent):
        """Construit l'interface de renommage du PC"""
        f = ctk.CTkFrame(parent)
        f.pack(fill="both", expand=True, padx=6, pady=6)
        ctk.CTkLabel(f, text="Renommer ce PC Windows", font=ctk.CTkFont(weight="bold")).pack(anchor="w", pady=(0, 6))
        
        ctk.CTkLabel(f, text="Nouveau nom du PC:").pack(anchor="w", pady=(4, 2))
        ctk.CTkEntry(f, textvariable=self.pc_name_var, width=300).pack(anchor="w", pady=(0, 6))
        
        ctk.CTkButton(f, text="Renommer le PC", width=220, fg_color="#2b6ee6", hover_color="#2058c9", command=self._run_rename_pc).pack(pady=6)
        ctk.CTkLabel(f, text="‚ö†Ô∏è N√©cessite un red√©marrage", text_color="#fca5a5").pack(anchor="w", pady=(6, 0))
    
    def _build_activate_windows_options(self, parent):
        """Construit l'interface d'activation Windows"""
        f = ctk.CTkFrame(parent)
        f.pack(fill="both", expand=True, padx=6, pady=6)
        ctk.CTkLabel(f, text="Activer Windows:", font=ctk.CTkFont(weight="bold")).pack(anchor="w", pady=(0, 6))
        
        fixed_cmd = 'irm https://get.activated.win| iex'
        ctk.CTkLabel(f, text="Commande (non modifiable):", text_color="#a8b3c6").pack(anchor="w")
        cmd_box = ctk.CTkTextbox(f, width=900, height=60, wrap="word")
        cmd_box.insert("0.0", fixed_cmd)
        cmd_box.configure(state="disabled")
        cmd_box.pack(fill="x", pady=(6, 8))
        
        ctk.CTkButton(f, text="‚ñ∂ Activer Windows", width=280, fg_color="#2b6ee6", hover_color="#2058c9", command=lambda: self._run_activate_windows(fixed_cmd)).pack(pady=6)
        ctk.CTkLabel(f, text="‚ö†Ô∏è Cette commande t√©l√©charge et ex√©cute du code distant.", text_color="#fca5a5").pack(anchor="w", pady=(8, 0))
    
    def _build_shortcuts_options(self, parent):
        """Construit l'interface de cr√©ation de raccourcis"""
        f = ctk.CTkFrame(parent)
        f.pack(fill="both", expand=True, padx=6, pady=6)
        ctk.CTkLabel(f, text="Cr√©er sur le Bureau : VELBO.lnk et VELSRV.lnk", font=ctk.CTkFont(weight="bold")).pack(anchor="w", pady=(0, 6))
        ctk.CTkLabel(f, text="Dossier contenant velbo.exe et velsrv.exe :").pack(anchor="w")
        folder_entry = ctk.CTkEntry(f, textvariable=self.shortcut_folder_var, width=520)
        folder_entry.pack(anchor="w", pady=(6, 8))
        ctk.CTkButton(f, text="Cr√©er les raccourcis", width=220, command=self._run_create_shortcuts).pack(pady=(4, 8))
    
    def _refresh_com_ports(self):
        """Rafra√Æchit la liste des ports COM"""
        ports = get_serial_ports()
        vals = ports if ports else ["Aucun d√©tect√©"]
        try:
            self.com_option.configure(values=vals)
            if ports:
                self.com_option.set(ports[0])
        except Exception:
            pass
        self.log(f"üîÑ Ports COM disponibles: {', '.join(ports) if ports else 'Aucun d√©tect√©'}")
    
    def _run_print_test(self):
        """Ex√©cute le test d'impression"""
        try:
            repeat = int(self.repeat_var.get().strip() or 1)
            lines = int(self.lines_var.get().strip() or 20)
        except Exception:
            self.log("‚ö†Ô∏è Valeurs de r√©p√©titions/lignes invalides")
            return
        
        text_to_print = self.print_text_var.get().strip() or "Test Test Test"
        mode = self.mode_var.get()
        ip = self.ip_var.get().strip()
        port = self.port_var.get().strip()
        com_port = self.com_var.get().strip()
        baud = self.baud_var.get().strip()
        
        data = build_message(n_lines_each=lines, text=text_to_print, mode=mode, ip=ip, port=port, com_port=com_port, baud=baud)
        
        self.log(f"--- D√âBUT DU TEST ({mode.upper()}) ---")
        
        def worker():
            for i in range(repeat):
                self.log(f"Ex√©cution {i+1}/{repeat}...")
                if mode.lower() == "tcp":
                    try:
                        port_num = int(port or 9100)
                    except:
                        port_num = 9100
                    send_tcp(ip, port_num, data, self.log)
                else:
                    if not com_port or com_port == "Aucun d√©tect√©":
                        self.log("‚ö†Ô∏è Aucun port COM s√©lectionn√©")
                        return
                    try:
                        baud_num = int(baud or 9600)
                    except:
                        baud_num = 9600
                    send_serial(com_port, baud_num, data, self.log)
                time.sleep(0.5)
            self.log("‚úÖ Test termin√©\n")
        
        threading.Thread(target=worker, daemon=True).start()
    
    def _run_check_port(self):
        """V√©rifie si un port est ouvert"""
        host = self.check_host_var.get().strip() or "127.0.0.1"
        try:
            port = int(self.check_port_var.get().strip())
        except:
            port = 40000
        
        threading.Thread(target=lambda: check_tcp_port(host, port, self.log), daemon=True).start()
    
    def _run_show_wifi_passwords(self):
        """R√©cup√®re les mots de passe WiFi"""
        threading.Thread(target=lambda: get_wifi_passwords(self.log), daemon=True).start()
    
    def _run_apply_wallpaper(self):
        """Applique le wallpaper s√©lectionn√©"""
        wallpaper = self.selected_wallpaper_var.get()
        if wallpaper:
            threading.Thread(target=lambda: apply_wallpaper(wallpaper, self.log), daemon=True).start()
        else:
            self.log("‚ùå Aucun wallpaper s√©lectionn√©")
    
    def _run_tweak_taskbar(self):
        """Applique les tweaks de la barre des t√¢ches"""
        threading.Thread(target=lambda: tweak_taskbar(self.log), daemon=True).start()
    
    def _run_disable_notifications(self):
        """D√©sactive les notifications Windows"""
        threading.Thread(target=lambda: disable_windows_notifications(self.log), daemon=True).start()
    
    def _run_restore_menu(self):
        """Restaure le menu contextuel classique"""
        threading.Thread(target=lambda: restore_context_menu(self.log), daemon=True).start()
    
    def _run_uninstall_kb(self):
        """D√©sinstalle KB5064081"""
        threading.Thread(target=lambda: uninstall_kb5064081(self.log), daemon=True).start()
    
    def _run_rename_pc(self):
        """Renomme le PC"""
        new_name = self.pc_name_var.get().strip()
        threading.Thread(target=lambda: rename_computer(new_name, self.log), daemon=True).start()
    
    def _run_activate_windows(self, cmd):
        """Active Windows via PowerShell"""
        def worker():
            self.log(f"‚ñ∂ Ex√©cution PowerShell: {cmd}")
            try:
                import subprocess
                proc = subprocess.run(
                    ["powershell", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", cmd],
                    capture_output=True, text=True, timeout=300
                )
                if proc.stdout:
                    self.log("----- PowerShell stdout -----")
                    for line in proc.stdout.splitlines():
                        self.log(line)
                if proc.stderr:
                    self.log("----- PowerShell stderr -----")
                    for line in proc.stderr.splitlines():
                        self.log(line)
                self.log(f"PowerShell termin√© (code {proc.returncode})")
            except Exception as e:
                self.log(f"‚ùå Erreur: {e}")
        
        threading.Thread(target=worker, daemon=True).start()
    
    def _show_system_info(self):
        """Affiche les informations syst√®me"""
        import platform
        import socket
        import getpass
        try:
            import psutil
            
            # Informations de base
            hostname = socket.gethostname()
            user = getpass.getuser()
            system = platform.system()
            release = platform.release()
            version = platform.version()
            
            # Processeur
            processor = platform.processor()
            cpu_count_physical = psutil.cpu_count(logical=False)
            cpu_count_logical = psutil.cpu_count(logical=True)
            cpu_freq = psutil.cpu_freq()
            cpu_usage = psutil.cpu_percent(interval=1)
            
            # M√©moire RAM
            ram = psutil.virtual_memory()
            ram_total = round(ram.total / (1024**3), 2)
            ram_used = round(ram.used / (1024**3), 2)
            ram_percent = ram.percent
            
            # Disques
            partitions = psutil.disk_partitions()
            
            self.log("=" * 60)
            self.log("                INFORMATIONS SYST√àME")
            self.log("=" * 60)
            
            self.log("\nüìã SYST√àME:")
            self.log(f"  Nom de l'ordinateur : {hostname}")
            self.log(f"  Utilisateur         : {user}")
            self.log(f"  OS                  : {system} {release}")
            self.log(f"  Version             : {version}")
            
            self.log("\nüîß PROCESSEUR:")
            self.log(f"  Mod√®le              : {processor}")
            self.log(f"  C≈ìurs physiques     : {cpu_count_physical}")
            self.log(f"  C≈ìurs logiques      : {cpu_count_logical}")
            if cpu_freq:
                self.log(f"  Fr√©quence           : {cpu_freq.current:.0f} MHz (max: {cpu_freq.max:.0f} MHz)")
            self.log(f"  Utilisation actuelle: {cpu_usage}%")
            
            self.log("\nüíæ M√âMOIRE RAM:")
            self.log(f"  Total               : {ram_total} GB")
            self.log(f"  Utilis√©e            : {ram_used} GB ({ram_percent}%)")
            self.log(f"  Disponible          : {round(ram.available / (1024**3), 2)} GB")
            
            self.log("\nüíø DISQUES:")
            for partition in partitions:
                try:
                    usage = psutil.disk_usage(partition.mountpoint)
                    total = round(usage.total / (1024**3), 2)
                    used = round(usage.used / (1024**3), 2)
                    free = round(usage.free / (1024**3), 2)
                    percent = usage.percent
                    
                    self.log(f"  {partition.device}")
                    self.log(f"    Point de montage  : {partition.mountpoint}")
                    self.log(f"    Syst√®me de fichiers: {partition.fstype}")
                    self.log(f"    Taille totale     : {total} GB")
                    self.log(f"    Espace utilis√©    : {used} GB ({percent}%)")
                    self.log(f"    Espace libre      : {free} GB")
                except Exception:
                    # Ignorer les lecteurs non accessibles
                    pass
            
            self.log("\n" + "=" * 60)
            
        except Exception as e:
            self.log(f"‚ùå Erreur lors de la r√©cup√©ration des infos syst√®me: {e}")
    
    def _run_create_shortcuts(self):
        """Cr√©e les raccourcis VELBO/VELSRV"""
        folder = self.shortcut_folder_var.get().strip()
        threading.Thread(target=lambda: create_veloce_shortcuts(folder, self.log), daemon=True).start()
    
    def _build_manage_users_options(self, parent):
        """Page de gestion des utilisateurs Windows"""
        f = ctk.CTkScrollableFrame(parent)
        f.pack(fill="both", expand=True, padx=6, pady=6)
        
        ctk.CTkLabel(f, text="Gestion des utilisateurs Windows", 
                     font=ctk.CTkFont(size=16, weight="bold")).pack(anchor="w", pady=(0,10))
        
        # Variables
        if not hasattr(self, 'user_name_var'):
            self.user_name_var = tk.StringVar(value="")
            self.user_pass_var = tk.StringVar(value="")
            self.user_admin_var = tk.BooleanVar(value=False)
        
        # Formulaire cr√©ation utilisateur
        form_frame = ctk.CTkFrame(f)
        form_frame.pack(fill="x", pady=8, padx=10)
        
        ctk.CTkLabel(form_frame, text="Nom d'utilisateur:").grid(row=0, column=0, sticky="w", padx=10, pady=5)
        ctk.CTkEntry(form_frame, textvariable=self.user_name_var, width=250).grid(row=0, column=1, padx=10, pady=5)
        
        ctk.CTkLabel(form_frame, text="Mot de passe:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        ctk.CTkEntry(form_frame, textvariable=self.user_pass_var, width=250, show="*").grid(row=1, column=1, padx=10, pady=5)
        
        ctk.CTkCheckBox(form_frame, text="Ajouter aux administrateurs", 
                       variable=self.user_admin_var).grid(row=2, column=0, columnspan=2, sticky="w", padx=10, pady=5)
        
        ctk.CTkButton(form_frame, text="‚ûï Cr√©er l'utilisateur", width=200,
                      command=self._create_user,
                      fg_color="#2b6ee6", hover_color="#2058c9").grid(row=3, column=0, columnspan=2, pady=10)
        
        # Boutons presets
        preset_frame = ctk.CTkFrame(f)
        preset_frame.pack(fill="x", pady=8, padx=10)
        
        ctk.CTkLabel(preset_frame, text="‚ö° Presets rapides:", 
                     font=ctk.CTkFont(size=13, weight="bold")).pack(anchor="w", padx=10, pady=(10,5))
        
        btn_grid = ctk.CTkFrame(preset_frame, fg_color="transparent")
        btn_grid.pack(fill="x", padx=10, pady=5)
        
        ctk.CTkButton(btn_grid, text="admin / veloce123", width=150,
                      command=lambda: (self.user_name_var.set("admin"), 
                                      self.user_pass_var.set("veloce123"),
                                      self.user_admin_var.set(True))).grid(row=0, column=0, padx=5, pady=5)
        
        ctk.CTkButton(btn_grid, text="kpitech / Log1tech", width=150,
                      command=lambda: (self.user_name_var.set("kpitech"), 
                                      self.user_pass_var.set("Log1tech"),
                                      self.user_admin_var.set(True))).grid(row=0, column=1, padx=5, pady=5)
        
        # Bouton lister les utilisateurs
        ctk.CTkButton(f, text="üìã Afficher tous les utilisateurs", width=250,
                      command=self._list_users,
                      fg_color="#16a34a", hover_color="#15803d").pack(pady=10)
    
    def _create_user(self):
        """Cr√©e un nouvel utilisateur Windows"""
        name = self.user_name_var.get().strip()
        password = self.user_pass_var.get().strip()
        is_admin = self.user_admin_var.get()
        
        if not name or not password:
            self.log("‚ùå Nom d'utilisateur et mot de passe requis")
            return
        
        threading.Thread(target=lambda: add_windows_user(name, password, is_admin, True, self.log), daemon=True).start()
    
    def _list_users(self):
        """Liste tous les utilisateurs Windows"""
        def worker():
            try:
                self.log("===== UTILISATEURS WINDOWS =====")
                result = subprocess.check_output("net user", shell=True, text=True)
                for line in result.splitlines():
                    if line.strip():
                        self.log(line)
                self.log("================================")
            except Exception as e:
                self.log(f"‚ùå Erreur: {e}")
        
        threading.Thread(target=worker, daemon=True).start()
    
    def _update_remote_ids(self):
        """Met √† jour les IDs TeamViewer et AnyDesk"""
        tv_id = get_teamviewer_id()
        ad_id = get_anydesk_id()
        self.after(0, lambda: self.tv_label.configure(text=f"TeamViewer ID: {tv_id}"))
        self.after(0, lambda: self.ad_label.configure(text=f"AnyDesk ID: {ad_id}"))
    
    def show_release_notes(self):
        """Affiche les notes de version dans une fen√™tre popup"""
        from tkinter import Toplevel
        from tkinter import scrolledtext
        
        base_path = get_base_path()
        notes_path = os.path.join(base_path, "config", "releasesnotes.txt")
        
        if not os.path.exists(notes_path):
            self.log(f"‚ùå Fichier releasesnotes.txt introuvable dans config/")
            messagebox.showwarning("Fichier introuvable", 
                                  "Le fichier releasesnotes.txt est manquant dans config/")
            return
        
        win = Toplevel(self)
        win.title("Release Notes - Outils Syst√®me")
        win.geometry("700x500")
        win.resizable(True, True)
        win.grab_set()
        
        txt_area = scrolledtext.ScrolledText(win, wrap="word", font=("Consolas", 11))
        txt_area.pack(expand=True, fill="both", padx=10, pady=10)
        
        try:
            with open(notes_path, "r", encoding="utf-8") as f:
                txt_area.insert("1.0", f.read())
        except Exception as e:
            txt_area.insert("1.0", f"Erreur lors de la lecture du fichier: {e}")
        
        txt_area.configure(state="disabled")
    
    def build_auto_setup_options(self, parent):
        """Page Auto Setup avec 3 boutons qui ouvrent des fen√™tres d√©di√©es"""
        f = ctk.CTkScrollableFrame(parent)
        f.pack(fill="both", expand=True, padx=6, pady=6)
        
        # Titre
        ctk.CTkLabel(f, text="Auto Setup - Configuration automatique", 
                     font=ctk.CTkFont(size=18, weight="bold")).pack(anchor="w", pady=(0,15))
        
        ctk.CTkLabel(f, text="S√©lectionnez le type de poste √† configurer :", 
                     font=ctk.CTkFont(size=12)).pack(anchor="w", pady=(0,10))
        
        # Boutons pour ouvrir chaque fen√™tre
        btn_frame = ctk.CTkFrame(f, fg_color="transparent")
        btn_frame.pack(fill="x", pady=10)
        
        ctk.CTkButton(btn_frame, text="üñ•Ô∏è Poste Standard", width=220, height=60,
                      font=ctk.CTkFont(size=14, weight="bold"),
                      fg_color="#16a34a", hover_color="#15803d",
                      command=self._open_standard_window).grid(row=0, column=0, padx=15, pady=10)
        
        ctk.CTkButton(btn_frame, text="üñ•Ô∏è Poste Serveur", width=220, height=60,
                      font=ctk.CTkFont(size=14, weight="bold"),
                      fg_color="#6b7280", hover_color="#4b5563",
                      command=self._open_serveur_window).grid(row=0, column=1, padx=15, pady=10)
        
        ctk.CTkButton(btn_frame, text="üí≥ Station Veloce", width=220, height=60,
                      font=ctk.CTkFont(size=14, weight="bold"),
                      fg_color="#2563eb", hover_color="#1d4ed8",
                      command=self._open_veloce_window).grid(row=0, column=2, padx=15, pady=10)
        
        # Descriptions
        desc_frame = ctk.CTkFrame(f)
        desc_frame.pack(fill="both", expand=True, pady=(15,0))
        
        ctk.CTkLabel(desc_frame, text="üìã Description des configurations :",
                     font=ctk.CTkFont(size=13, weight="bold")).pack(anchor="w", padx=15, pady=(15,10))
        
        descriptions = """
‚Ä¢ Poste Standard:
  - Tweaks Windows (barre t√¢ches, notifications)
  - Cr√©ation utilisateurs (admin, kpitech)
  - Wallpaper KPI
  - Renommage PC optionnel
  
‚Ä¢ Poste Serveur:
  - En attente de d√©finition
  
‚Ä¢ Station Veloce:
  - Installation automatique r√©seau
  - Configuration POS compl√®te
"""
        
        ctk.CTkLabel(desc_frame, text=descriptions, justify="left",
                     font=ctk.CTkFont(size=11)).pack(anchor="w", padx=25, pady=(0,15))
    
    def _open_standard_window(self):
        """Ouvre la fen√™tre Poste Standard avec tous les champs visibles"""
        from tkinter import Toplevel
        
        # Cr√©er la fen√™tre
        window = Toplevel(self)
        window.title("Auto Setup - Poste Standard")
        window.geometry("900x650")
        window.resizable(True, True)
        window.transient(self)
        window.grab_set()
        
        # Frame principal
        main_frame = ctk.CTkFrame(window)
        main_frame.pack(fill="both", expand=True, padx=15, pady=15)
        
        # Titre
        ctk.CTkLabel(main_frame, text="üñ•Ô∏è Configuration Poste Standard",
                     font=ctk.CTkFont(size=16, weight="bold")).pack(pady=(0,10))
        
        # Variables
        vars_dict = {
            'taskbar': tk.BooleanVar(value=True),
            'notifications': tk.BooleanVar(value=True),
            'user_admin': tk.BooleanVar(value=True),
            'user_kpitech': tk.BooleanVar(value=True),
            'wallpaper': tk.BooleanVar(value=True),
        }
        rename_var = tk.BooleanVar(value=False)
        pc_name_var = tk.StringVar(value="")
        restart_var = tk.BooleanVar(value=False)
        
        # Container horizontal: Options GAUCHE | Log DROITE
        content_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, pady=(0,8))
        
        # === GAUCHE: Options ===
        left_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        left_frame.pack(side="left", fill="both", expand=True, padx=(0,6))
        
        # √âtapes
        steps_frame = ctk.CTkFrame(left_frame, fg_color="#2b2b2b")
        steps_frame.pack(fill="both", expand=True)
        
        ctk.CTkLabel(steps_frame, text="üìã √âtapes √† ex√©cuter :",
                     font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", padx=10, pady=(8,4))
        
        ctk.CTkCheckBox(steps_frame, text="‚úì Tweak barre des t√¢ches",
                       variable=vars_dict['taskbar'], font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=1)
        ctk.CTkCheckBox(steps_frame, text="‚úì D√©sactiver notifications",
                       variable=vars_dict['notifications'], font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=1)
        ctk.CTkCheckBox(steps_frame, text="‚úì Cr√©er user 'admin'",
                       variable=vars_dict['user_admin'], font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=1)
        ctk.CTkCheckBox(steps_frame, text="‚úì Cr√©er user 'kpitech'",
                       variable=vars_dict['user_kpitech'], font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=1)
        ctk.CTkCheckBox(steps_frame, text="‚úì Wallpaper KPI",
                       variable=vars_dict['wallpaper'], font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=1)
        
        ctk.CTkLabel(steps_frame, text="‚öôÔ∏è Options :",
                     font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", padx=10, pady=(8,4))
        
        # Renommer PC
        ctk.CTkCheckBox(steps_frame, text="Renommer le PC:",
                       variable=rename_var, font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=2)
        ctk.CTkEntry(steps_frame, textvariable=pc_name_var,
                    placeholder_text="Nom du PC",
                    width=200, height=26).pack(anchor="w", padx=12, pady=2)
        
        ctk.CTkCheckBox(steps_frame, text="Red√©marrer auto",
                       variable=restart_var, font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=(4,8))
        
        # === DROITE: Progression ===
        right_frame = ctk.CTkFrame(content_frame)
        right_frame.pack(side="right", fill="both", expand=True)
        
        ctk.CTkLabel(right_frame, text="üìä Progression",
                     font=ctk.CTkFont(size=12, weight="bold")).pack(pady=(8,4))
        
        status_label = ctk.CTkLabel(right_frame, text="Pr√™t √† d√©marrer...",
                                   font=ctk.CTkFont(size=12))
        status_label.pack(pady=2)
        
        progress_bar = ctk.CTkProgressBar(right_frame, width=280)
        progress_bar.pack(pady=3)
        progress_bar.set(0)
        
        log_box = ctk.CTkTextbox(right_frame, width=300)
        log_box.pack(fill="both", expand=True, padx=6, pady=6)
        
        # Fonction pour ex√©cuter
        def execute():
            def log_msg(msg):
                log_box.insert("end", msg + "\n")
                log_box.see("end")
                self.log(msg)
            
            def worker():
                try:
                    log_msg("===== AUTO SETUP: POSTE STANDARD =====")
                    
                    # Collecter les √©tapes
                    steps = []
                    if vars_dict['taskbar'].get():
                        steps.append(("Tweak barre des t√¢ches", lambda: tweak_taskbar(self.log)))
                    if vars_dict['notifications'].get():
                        steps.append(("D√©sactivation notifications", lambda: disable_windows_notifications(self.log)))
                    if vars_dict['user_admin'].get():
                        steps.append(("Cr√©ation utilisateur 'admin'", lambda: add_windows_user("admin", "veloce123", True, True, self.log)))
                    if vars_dict['user_kpitech'].get():
                        steps.append(("Cr√©ation utilisateur 'kpitech'", lambda: add_windows_user("kpitech", "Log1tech", True, True, self.log)))
                    if vars_dict['wallpaper'].get():
                        steps.append(("Application wallpaper KPI", lambda: apply_wallpaper("wallpaper-kpi.jpg", self.log)))
                    
                    if not steps:
                        log_msg("‚ö†Ô∏è Aucune √©tape s√©lectionn√©e")
                        status_label.configure(text="‚ö†Ô∏è Aucune √©tape s√©lectionn√©e")
                        return
                    
                    total = len(steps)
                    
                    # Ex√©cuter
                    for i, (name, action) in enumerate(steps, 1):
                        status_label.configure(text=f"‚ñ∂ √âtape {i}/{total}: {name}...")
                        log_msg(f"‚ñ∂ √âtape {i}/{total}: {name}...")
                        try:
                            action()
                            log_msg("‚úÖ Termin√©")
                        except Exception as e:
                            log_msg(f"‚ùå Erreur: {e}")
                        progress_bar.set(i / total)
                        time.sleep(0.5)
                    
                    # Renommer PC
                    if rename_var.get():
                        new_name = pc_name_var.get().strip()
                        if new_name:
                            status_label.configure(text="‚ñ∂ Renommage du PC...")
                            log_msg(f"‚ñ∂ Renommage du PC en '{new_name}'...")
                            try:
                                rename_computer(new_name, self.log)
                                log_msg("‚úÖ PC renomm√© avec succ√®s")
                            except Exception as e:
                                log_msg(f"‚ùå Erreur renommage: {e}")
                    
                    status_label.configure(text="‚úÖ Configuration termin√©e!")
                    log_msg("=" * 50)
                    log_msg("‚úÖ AUTO SETUP POSTE STANDARD TERMIN√â!")
                    
                    # Red√©marrage
                    if restart_var.get() and rename_var.get() and pc_name_var.get().strip():
                        log_msg("üîÑ Red√©marrage du syst√®me dans 10 secondes...")
                        subprocess.run("shutdown /r /t 10", shell=True)
                        log_msg("‚úÖ Red√©marrage planifi√©")
                    
                except Exception as e:
                    log_msg(f"‚ùå Erreur fatale: {e}")
                    status_label.configure(text="‚ùå Erreur")
            
            log_box.delete("1.0", "end")
            progress_bar.set(0)
            threading.Thread(target=worker, daemon=True).start()
        
        # Bouton d√©marrer
        ctk.CTkButton(main_frame, text="üöÄ D√©marrer la configuration",
                      width=350, height=42,
                      font=ctk.CTkFont(size=13, weight="bold"),
                      fg_color="#16a34a", hover_color="#15803d",
                      command=execute).pack(pady=6)
    
    def _open_serveur_window(self):
        """Ouvre la fen√™tre Poste Serveur"""
        from tkinter import Toplevel
        
        window = Toplevel(self)
        window.title("Auto Setup - Poste Serveur")
        window.geometry("500x300")
        window.resizable(False, False)
        window.transient(self)
        window.grab_set()
        
        main_frame = ctk.CTkFrame(window)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        ctk.CTkLabel(main_frame, text="‚ö†Ô∏è Configuration en attente",
                     font=ctk.CTkFont(size=16, weight="bold"),
                     text_color="#fbbf24").pack(pady=(50,20))
        
        ctk.CTkLabel(main_frame, text="La configuration automatique pour Poste Serveur\nest en cours de d√©finition.",
                     font=ctk.CTkFont(size=12),
                     justify="center").pack(pady=(0,50))
    
    def _open_veloce_window(self):
        """Ouvre la fen√™tre Station Veloce avec les 2 champs visibles"""
        from tkinter import Toplevel
        
        window = Toplevel(self)
        window.title("Auto Setup - Station Veloce")
        window.geometry("900x650")
        window.resizable(True, True)
        window.transient(self)
        window.grab_set()
        
        # Frame principal
        main_frame = ctk.CTkFrame(window)
        main_frame.pack(fill="both", expand=True, padx=15, pady=15)
        
        # Titre
        ctk.CTkLabel(main_frame, text="üí≥ Configuration Station Veloce",
                     font=ctk.CTkFont(size=16, weight="bold")).pack(pady=(0,10))
        
        server_var = tk.StringVar(value="SV")
        station_var = tk.StringVar(value="")
        
        # Container horizontal: Param√®tres GAUCHE | Log DROITE
        content_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, pady=(0,8))
        
        # === GAUCHE: Param√®tres ===
        left_frame = ctk.CTkFrame(content_frame, fg_color="#2b2b2b")
        left_frame.pack(side="left", fill="both", expand=True, padx=(0,6))
        
        ctk.CTkLabel(left_frame, text="üí≥ √âtapes de configuration :",
                     font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", padx=10, pady=(8,4))
        
        desc_text = """‚úì V√©rification acc√®s r√©seau
‚úì Installation install (WSXX).exe
‚úì Raccourci bureau
‚úì Cl√© registre + D√©marrage"""
        ctk.CTkLabel(left_frame, text=desc_text, justify="left",
                     font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=(0,8))
        
        ctk.CTkLabel(left_frame, text="‚öôÔ∏è Param√®tres :",
                     font=ctk.CTkFont(size=14, weight="bold")).pack(anchor="w", padx=10, pady=(4,4))
        
        # Serveur
        ctk.CTkLabel(left_frame, text="Nom du serveur:",
                     font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=(4,2))
        ctk.CTkEntry(left_frame, textvariable=server_var, width=220, height=26,
                     placeholder_text="Ex: SV",
                     font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=2)
        
        # Station
        ctk.CTkLabel(left_frame, text="Num√©ro de station:",
                     font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=(6,2))
        ctk.CTkEntry(left_frame, textvariable=station_var, width=220, height=26,
                     placeholder_text="Ex: 1, 2, 15...",
                     font=ctk.CTkFont(size=12)).pack(anchor="w", padx=12, pady=2)
        
        # Info chemin
        ctk.CTkLabel(left_frame, text="‚ÑπÔ∏è \\\\[SERVEUR]\\veloce\\stat[XX]\\install\\",
                     font=ctk.CTkFont(size=12),
                     text_color="#a5d6ff").pack(anchor="w", padx=12, pady=(8,8))
        
        # === DROITE: Progression ===
        right_frame = ctk.CTkFrame(content_frame)
        right_frame.pack(side="right", fill="both", expand=True)
        
        ctk.CTkLabel(right_frame, text="üìä Progression",
                     font=ctk.CTkFont(size=14, weight="bold")).pack(pady=(8,4))
        
        status_label = ctk.CTkLabel(right_frame, text="Pr√™t √† d√©marrer...",
                                   font=ctk.CTkFont(size=12))
        status_label.pack(pady=2)
        
        progress_bar = ctk.CTkProgressBar(right_frame, width=280)
        progress_bar.pack(pady=3)
        progress_bar.set(0)
        
        log_box = ctk.CTkTextbox(right_frame, width=300)
        log_box.pack(fill="both", expand=True, padx=6, pady=6)
        
        # Fonction ex√©cution
        def execute():
            server = server_var.get().strip()
            station = station_var.get().strip()
            
            if not server:
                messagebox.showerror("Erreur", "Veuillez entrer le nom du serveur", parent=window)
                return
            
            if not station or not station.isdigit():
                messagebox.showerror("Erreur", "Veuillez entrer un num√©ro de station valide (1-99)", parent=window)
                return
            
            station_num = int(station)
            if station_num < 1 or station_num > 99:
                messagebox.showerror("Erreur", "Le num√©ro de station doit √™tre entre 1 et 99", parent=window)
                return
            
            # Lancer la configuration
            log_box.delete("1.0", "end")
            progress_bar.set(0)
            self._run_auto_setup_veloce_inline(window, server, station_num, status_label, progress_bar, log_box)
        
        # Bouton d√©marrer
        ctk.CTkButton(main_frame, text="üöÄ D√©marrer l'installation",
                      width=350, height=42,
                      font=ctk.CTkFont(size=13, weight="bold"),
                      fg_color="#2563eb", hover_color="#1d4ed8",
                      command=execute).pack(pady=6)
    
    def _run_auto_setup_veloce_inline(self, window, server, station_num, status_label, progress_bar, log_box):
        """Ex√©cute Station Veloce dans la fen√™tre (pas de popup)"""
        def log_msg(msg):
            log_box.insert("end", msg + "\n")
            log_box.see("end")
            self.log(msg)
        
        def worker():
            try:
                log_msg(f"===== AUTO SETUP: STATION VELOCE =====")
                
                # Format station
                station_formatted = f"{station_num:02d}"
                station_no_zero = str(station_num)
                
                log_msg(f"Serveur: {server}")
                log_msg(f"Num√©ro de station: {station_num} (format√©: {station_formatted})")
                progress_bar.set(0.1)
                
                # Chemins
                veloce_base = f"\\\\{server}\\veloce"
                station_folder = f"stat{station_formatted}"
                station_path = os.path.join(veloce_base, station_folder, "install")
                install_exe = os.path.join(station_path, f"install (WS{station_formatted}).exe")
                ws_starter = os.path.join(station_path, f"WS Starter{station_no_zero}.exe")
                desktop = os.path.join(os.path.expanduser("~"), "Desktop")
                appdata = os.getenv("APPDATA") or os.path.expanduser("~")
                startup_folder = os.path.join(appdata, "Microsoft", "Windows", "Start Menu", "Programs", "Startup")
                
                # √âtape 1: Ping serveur
                status_label.configure(text="V√©rification acc√®s r√©seau...")
                log_msg(f"‚ñ∂ V√©rification acc√®s √† {veloce_base}...")
                
                ping_result = subprocess.run(
                    f"ping -n 1 -w 1000 {server}",
                    shell=True, capture_output=True, timeout=2
                )
                
                if ping_result.returncode != 0:
                    log_msg(f"‚ùå Serveur {server} non joignable")
                    status_label.configure(text="‚ùå Serveur non joignable")
                    progress_bar.set(1.0)
                    return
                
                log_msg(f"‚úì Serveur {server} joignable")
                
                if not os.path.exists(station_path):
                    log_msg(f"‚ùå Dossier {station_folder} introuvable")
                    log_msg(f"Chemin: {station_path}")
                    status_label.configure(text="‚ùå Dossier station introuvable")
                    progress_bar.set(1.0)
                    return
                
                log_msg(f"‚úì Dossier station accessible: {station_path}")
                progress_bar.set(0.2)
                
                # √âtape 2: Installer
                status_label.configure(text="Installation de l'application...")
                log_msg(f"‚ñ∂ Lancement de install (WS{station_formatted}).exe en mode admin...")
                
                if not os.path.exists(install_exe):
                    log_msg(f"‚ùå Fichier introuvable: {install_exe}")
                    status_label.configure(text="‚ùå Fichier install introuvable")
                    progress_bar.set(1.0)
                    return
                
                import ctypes
                ret = ctypes.windll.shell32.ShellExecuteW(
                    None, "runas", install_exe, None, station_path, 1
                )
                
                if ret > 32:
                    log_msg(f"‚úì install (WS{station_formatted}).exe lanc√© avec succ√®s")
                else:
                    log_msg(f"‚ùå √âchec du lancement (code: {ret})")
                    status_label.configure(text="‚ùå Erreur installation")
                    progress_bar.set(1.0)
                    return
                
                progress_bar.set(0.4)
                time.sleep(1)
                
                # √âtape 3: Raccourci bureau
                status_label.configure(text="Cr√©ation du raccourci bureau...")
                log_msg(f"‚ñ∂ Cr√©ation du raccourci 'station {station_no_zero}' sur le bureau...")
                
                if not os.path.exists(ws_starter):
                    log_msg(f"‚ùå Fichier source introuvable: {ws_starter}")
                    status_label.configure(text="‚ùå WS Starter introuvable")
                    progress_bar.set(1.0)
                    return
                
                shortcut_path = os.path.join(desktop, f"station {station_no_zero}.lnk")
                ps_script = f'''
$WScriptShell = New-Object -ComObject WScript.Shell
$Shortcut = $WScriptShell.CreateShortcut("{shortcut_path}")
$Shortcut.TargetPath = "{ws_starter}"
$Shortcut.WorkingDirectory = "{station_path}"
$Shortcut.Save()
'''
                ps_cmd = ['powershell', '-ExecutionPolicy', 'Bypass', '-Command', ps_script]
                result = subprocess.run(ps_cmd, capture_output=True, text=True)
                
                if result.returncode == 0 and os.path.exists(shortcut_path):
                    log_msg(f"‚úì Raccourci cr√©√©: {shortcut_path}")
                else:
                    log_msg(f"‚ùå Erreur cr√©ation raccourci: {result.stderr}")
                    log_msg("‚ö†Ô∏è Continuez manuellement...")
                
                progress_bar.set(0.6)
                
                # Continue avec le reste des √©tapes...
                status_label.configure(text="‚úÖ Configuration termin√©e!")
                log_msg("=" * 50)
                log_msg("‚úÖ AUTO SETUP STATION VELOCE TERMIN√â!")
                progress_bar.set(1.0)
                
            except Exception as e:
                log_msg(f"‚ùå Erreur fatale: {e}")
                status_label.configure(text="‚ùå Erreur")
        
        threading.Thread(target=worker, daemon=True).start()
    
    def _build_standard_ui(self):
        """Construit l'UI pour Poste Standard"""
        frame = self._auto_config_frame
        
        # Description
        desc_frame = ctk.CTkFrame(frame, fg_color="#2b2b2b")
        desc_frame.pack(fill="x", padx=15, pady=10)
        
        ctk.CTkLabel(desc_frame, text="üìã S√©lectionnez les √©tapes √† ex√©cuter :",
                     font=ctk.CTkFont(size=13, weight="bold")).pack(anchor="w", padx=20, pady=(15,10))
        
        # Checkboxes pour les √©tapes
        if not hasattr(self, '_standard_steps_vars'):
            self._standard_steps_vars = {
                'taskbar': tk.BooleanVar(value=True),
                'notifications': tk.BooleanVar(value=True),
                'user_admin': tk.BooleanVar(value=True),
                'user_kpitech': tk.BooleanVar(value=True),
                'wallpaper': tk.BooleanVar(value=True),
            }
            self._standard_rename_var = tk.BooleanVar(value=False)
            self._standard_pc_name_var = tk.StringVar(value="")
            self._standard_restart_var = tk.BooleanVar(value=False)
        
        checks_frame = ctk.CTkFrame(desc_frame, fg_color="transparent")
        checks_frame.pack(fill="x", padx=20, pady=(0,15))
        
        ctk.CTkCheckBox(checks_frame, text="‚úì Tweak barre des t√¢ches",
                       variable=self._standard_steps_vars['taskbar']).pack(anchor="w", pady=3)
        ctk.CTkCheckBox(checks_frame, text="‚úì D√©sactiver notifications Windows",
                       variable=self._standard_steps_vars['notifications']).pack(anchor="w", pady=3)
        ctk.CTkCheckBox(checks_frame, text="‚úì Cr√©er utilisateur 'admin' (veloce123)",
                       variable=self._standard_steps_vars['user_admin']).pack(anchor="w", pady=3)
        ctk.CTkCheckBox(checks_frame, text="‚úì Cr√©er utilisateur 'kpitech' (Log1tech)",
                       variable=self._standard_steps_vars['user_kpitech']).pack(anchor="w", pady=3)
        ctk.CTkCheckBox(checks_frame, text="‚úì Appliquer wallpaper KPI",
                       variable=self._standard_steps_vars['wallpaper']).pack(anchor="w", pady=3)
        
        # Options suppl√©mentaires
        options_frame = ctk.CTkFrame(frame)
        options_frame.pack(fill="x", padx=15, pady=10)
        
        ctk.CTkLabel(options_frame, text="‚öôÔ∏è Options suppl√©mentaires :",
                     font=ctk.CTkFont(size=13, weight="bold")).pack(anchor="w", padx=20, pady=(15,10))
        
        # Renommer PC
        rename_frame = ctk.CTkFrame(options_frame, fg_color="transparent")
        rename_frame.pack(fill="x", padx=20, pady=5)
        
        ctk.CTkCheckBox(rename_frame, text="Renommer le PC :",
                       variable=self._standard_rename_var).pack(side="left")
        ctk.CTkEntry(rename_frame, textvariable=self._standard_pc_name_var,
                    placeholder_text="Nouveau nom du PC",
                    width=250).pack(side="left", padx=10)
        
        # Red√©marrage
        ctk.CTkCheckBox(options_frame, text="Red√©marrer automatiquement apr√®s configuration",
                       variable=self._standard_restart_var).pack(anchor="w", padx=20, pady=(10,15))
        
        # Zone de progression
        self._standard_progress_frame = ctk.CTkFrame(frame)
        self._standard_progress_frame.pack(fill="both", expand=True, padx=15, pady=10)
        
        self._standard_status_label = ctk.CTkLabel(self._standard_progress_frame, 
                                                   text="Pr√™t √† d√©marrer...",
                                                   font=ctk.CTkFont(size=12))
        self._standard_status_label.pack(pady=10)
        
        self._standard_progress_bar = ctk.CTkProgressBar(self._standard_progress_frame, width=400)
        self._standard_progress_bar.pack(pady=10)
        self._standard_progress_bar.set(0)
        
        self._standard_log_box = ctk.CTkTextbox(self._standard_progress_frame, height=150)
        self._standard_log_box.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Bouton d√©marrer
        ctk.CTkButton(frame, text="üöÄ D√©marrer la configuration", 
                      width=300, height=45,
                      font=ctk.CTkFont(size=14, weight="bold"),
                      fg_color="#16a34a", hover_color="#15803d",
                      command=self._start_standard_setup).pack(pady=20)
    
    def _start_standard_setup(self):
        """D√©marre la configuration Standard (inline, sans popup)"""
        def log_inline(msg):
            """Ajoute un message au log inline"""
            self._standard_log_box.insert("end", msg + "\n")
            self._standard_log_box.see("end")
            self.log(msg)
        
        def worker():
            try:
                log_inline("===== AUTO SETUP: POSTE STANDARD =====")
                
                # Collecter les √©tapes √† ex√©cuter
                steps = []
                if self._standard_steps_vars['taskbar'].get():
                    steps.append(("Tweak barre des t√¢ches", lambda: tweak_taskbar(self.log)))
                if self._standard_steps_vars['notifications'].get():
                    steps.append(("D√©sactivation notifications", lambda: disable_windows_notifications(self.log)))
                if self._standard_steps_vars['user_admin'].get():
                    steps.append(("Cr√©ation utilisateur 'admin'", lambda: add_windows_user("admin", "veloce123", True, True, self.log)))
                if self._standard_steps_vars['user_kpitech'].get():
                    steps.append(("Cr√©ation utilisateur 'kpitech'", lambda: add_windows_user("kpitech", "Log1tech", True, True, self.log)))
                if self._standard_steps_vars['wallpaper'].get():
                    steps.append(("Application wallpaper KPI", lambda: apply_wallpaper("wallpaper-kpi.jpg", self.log)))
                
                if not steps:
                    log_inline("‚ö†Ô∏è Aucune √©tape s√©lectionn√©e")
                    self._standard_status_label.configure(text="‚ö†Ô∏è Aucune √©tape s√©lectionn√©e")
                    return
                
                total = len(steps)
                
                # Ex√©cuter les √©tapes
                for i, (name, action) in enumerate(steps, 1):
                    self._standard_status_label.configure(text=f"‚ñ∂ √âtape {i}/{total}: {name}...")
                    log_inline(f"‚ñ∂ √âtape {i}/{total}: {name}...")
                    
                    try:
                        action()
                        log_inline("‚úÖ Termin√©")
                    except Exception as e:
                        log_inline(f"‚ùå Erreur: {e}")
                    
                    self._standard_progress_bar.set(i / total)
                    time.sleep(0.5)
                
                # Renommer le PC si demand√©
                if self._standard_rename_var.get():
                    new_name = self._standard_pc_name_var.get().strip()
                    if new_name:
                        self._standard_status_label.configure(text="‚ñ∂ Renommage du PC...")
                        log_inline(f"‚ñ∂ Renommage du PC en '{new_name}'...")
                        try:
                            rename_computer(new_name, self.log)
                            log_inline("‚úÖ PC renomm√© avec succ√®s")
                        except Exception as e:
                            log_inline(f"‚ùå Erreur renommage: {e}")
                    else:
                        log_inline("‚ö†Ô∏è Renommage demand√© mais aucun nom fourni")
                
                self._standard_status_label.configure(text="‚úÖ Configuration termin√©e!")
                log_inline("=" * 50)
                log_inline("‚úÖ AUTO SETUP POSTE STANDARD TERMIN√â!")
                
                # Red√©marrage si demand√©
                if self._standard_restart_var.get():
                    if self._standard_rename_var.get() and self._standard_pc_name_var.get().strip():
                        log_inline("üîÑ Red√©marrage du syst√®me dans 10 secondes...")
                        subprocess.run("shutdown /r /t 10", shell=True)
                        log_inline("‚úÖ Red√©marrage planifi√©")
                
            except Exception as e:
                log_inline(f"‚ùå Erreur fatale: {e}")
                self._standard_status_label.configure(text="‚ùå Erreur")
        
        # R√©initialiser l'UI
        self._standard_log_box.delete("1.0", "end")
        self._standard_progress_bar.set(0)
        
        # Lancer en thread
        threading.Thread(target=worker, daemon=True).start()
    
    def _build_serveur_ui(self):
        """Construit l'UI pour Poste Serveur"""
        frame = self._auto_config_frame
        
        info_frame = ctk.CTkFrame(frame, fg_color="#3a3a3a")
        info_frame.pack(fill="both", expand=True, padx=15, pady=15)
        
        ctk.CTkLabel(info_frame, text="‚ö†Ô∏è Configuration en attente",
                     font=ctk.CTkFont(size=16, weight="bold"),
                     text_color="#fbbf24").pack(pady=(30,10))
        
        ctk.CTkLabel(info_frame, text="La configuration automatique pour Poste Serveur\nest en cours de d√©finition.",
                     font=ctk.CTkFont(size=12),
                     justify="center").pack(pady=(0,30))
    
    def _build_veloce_ui(self):
        """Construit l'UI pour Station Veloce"""
        frame = self._auto_config_frame
        
        # Description
        desc_frame = ctk.CTkFrame(frame, fg_color="#2b2b2b")
        desc_frame.pack(fill="x", padx=15, pady=10)
        
        desc_text = """üí≥ Configuration Station Veloce :
        
‚úì V√©rification acc√®s r√©seau au serveur
‚úì Installation de install (WSXX).exe en mode admin
‚úì Cr√©ation raccourci bureau "station X"
‚úì Application cl√© registre DirectoryCacheLifetime
‚úì Copie dans D√©marrage Windows
‚úì Suppression ancien raccourci Veloce"""
        
        ctk.CTkLabel(desc_frame, text=desc_text, justify="left",
                     font=ctk.CTkFont(size=11)).pack(padx=20, pady=15)
        
        # Champs de saisie
        if not hasattr(self, '_veloce_server_var'):
            self._veloce_server_var = tk.StringVar(value="")
            self._veloce_station_var = tk.StringVar(value="")
        
        fields_frame = ctk.CTkFrame(frame)
        fields_frame.pack(fill="x", padx=15, pady=10)
        
        # Nom du serveur
        row1 = ctk.CTkFrame(fields_frame, fg_color="transparent")
        row1.pack(fill="x", pady=8)
        ctk.CTkLabel(row1, text="Nom du serveur:", width=150, anchor="w",
                     font=ctk.CTkFont(size=12)).pack(side="left", padx=10)
        ctk.CTkEntry(row1, textvariable=self._veloce_server_var, width=300,
                     placeholder_text="Ex: SV",
                     font=ctk.CTkFont(size=12)).pack(side="left", padx=10)
        
        # Num√©ro de station
        row2 = ctk.CTkFrame(fields_frame, fg_color="transparent")
        row2.pack(fill="x", pady=8)
        ctk.CTkLabel(row2, text="Num√©ro de station:", width=150, anchor="w",
                     font=ctk.CTkFont(size=12)).pack(side="left", padx=10)
        ctk.CTkEntry(row2, textvariable=self._veloce_station_var, width=300,
                     placeholder_text="Ex: 1, 2, 15...",
                     font=ctk.CTkFont(size=12)).pack(side="left", padx=10)
        
        # Info chemin
        info_frame = ctk.CTkFrame(frame, fg_color="#3a3a3a")
        info_frame.pack(fill="x", padx=15, pady=10)
        
        ctk.CTkLabel(info_frame, text="‚ÑπÔ∏è Le chemin utilis√© sera: \\\\[SERVEUR]\\veloce\\stat[XX]\\install\\",
                     font=ctk.CTkFont(size=10),
                     text_color="#a5d6ff").pack(padx=15, pady=10)
        
        # Bouton d√©marrer
        ctk.CTkButton(frame, text="üöÄ D√©marrer l'installation", 
                      width=300, height=45,
                      font=ctk.CTkFont(size=14, weight="bold"),
                      fg_color="#2563eb", hover_color="#1d4ed8",
                      command=self._start_veloce_setup).pack(pady=20)
    
    def _start_veloce_setup(self):
        """D√©marre la configuration Station Veloce"""
        server = self._veloce_server_var.get().strip()
        station = self._veloce_station_var.get().strip()
        
        if not server:
            messagebox.showerror("Erreur", "Veuillez entrer le nom du serveur")
            return
        
        if not station or not station.isdigit():
            messagebox.showerror("Erreur", "Veuillez entrer un num√©ro de station valide (1-99)")
            return
        
        station_num = int(station)
        if station_num < 1 or station_num > 99:
            messagebox.showerror("Erreur", "Le num√©ro de station doit √™tre entre 1 et 99")
            return
        
        # Lancer la configuration avec les param√®tres
        self._run_auto_setup("veloce", server_name=server, station_number=station_num)
    
    def _run_auto_setup(self, setup_type, server_name=None, station_number=None):
        """Ex√©cute la configuration automatique selon le type avec dialogue step-by-step"""
        from tkinter import Toplevel, messagebox
        
        # Fen√™tre de dialogue
        dialog = Toplevel(self)
        dialog.title(f"Auto Setup - {setup_type.upper()}")
        dialog.geometry("750x650")
        dialog.resizable(False, False)
        dialog.transient(self)
        dialog.grab_set()
        
        # Frame principal
        main_frame = ctk.CTkFrame(dialog)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Titre
        ctk.CTkLabel(main_frame, text=f"Configuration {setup_type.upper()}", 
                     font=ctk.CTkFont(size=18, weight="bold")).pack(pady=10)
        
        # Label pour l'√©tape courante
        step_label = ctk.CTkLabel(main_frame, text="Pr√™t √† d√©marrer...", 
                                   font=ctk.CTkFont(size=13))
        step_label.pack(pady=10)
        
        # Barre de progression
        progress_bar = ctk.CTkProgressBar(main_frame, width=400)
        progress_bar.pack(pady=10)
        progress_bar.set(0)
        
        # Log frame
        log_frame = ctk.CTkTextbox(main_frame, width=550, height=200)
        log_frame.pack(pady=10, fill="both", expand=True)
        
        def log_to_dialog(msg):
            """Ajoute un message au log de la fen√™tre"""
            log_frame.insert("end", msg + "\n")
            log_frame.see("end")
            self.log(msg)
        
        def run_worker(server_name=None, station_number=None):
            """Ex√©cute les √©tapes de configuration"""
            log_to_dialog(f"===== AUTO SETUP: {setup_type.upper()} =====")
            
            if setup_type == "standard":
                steps = [
                    ("Tweak barre des t√¢ches", lambda: tweak_taskbar(self.log)),
                    ("D√©sactivation notifications", lambda: disable_windows_notifications(self.log)),
                    ("Cr√©ation utilisateur 'admin'", lambda: add_windows_user("admin", "veloce123", True, True, self.log)),
                    ("Cr√©ation utilisateur 'kpitech'", lambda: add_windows_user("kpitech", "Log1tech", True, True, self.log)),
                    ("Application wallpaper KPI", lambda: apply_wallpaper("wallpaper-kpi.jpg", self.log))
                ]
                
                pc_renamed = False
                total = len(steps)
                for i, (name, action) in enumerate(steps, 1):
                    # Demander confirmation
                    dialog.update()
                    result = messagebox.askyesno("Confirmation", 
                                                f"√âtape {i}/{total}: {name}\n\nEx√©cuter cette √©tape ?",
                                                parent=dialog)
                    
                    if result:
                        step_label.configure(text=f"‚ñ∂ √âtape {i}/{total}: {name}...")
                        log_to_dialog(f"‚ñ∂ √âtape {i}/{total}: {name}...")
                        try:
                            action()
                            log_to_dialog("‚úÖ Termin√©")
                        except Exception as e:
                            log_to_dialog(f"‚ùå Erreur: {e}")
                    else:
                        log_to_dialog(f"‚è≠Ô∏è √âtape {i}/{total} ignor√©e: {name}")
                    
                    progress_bar.set(i / total)
                    time.sleep(0.5)
                
                # √âtape suppl√©mentaire : Renommer le PC ?
                dialog.update()
                if messagebox.askyesno("Renommer le PC ?", 
                                      "Voulez-vous renommer ce PC ?\n\n(Un red√©marrage sera n√©cessaire)",
                                      parent=dialog):
                    from tkinter import simpledialog
                    new_name = simpledialog.askstring("Nouveau nom du PC", 
                                                      "Entrez le nouveau nom du PC:",
                                                      parent=dialog)
                    if new_name and new_name.strip():
                        step_label.configure(text="‚ñ∂ Renommage du PC...")
                        log_to_dialog(f"‚ñ∂ Renommage du PC en '{new_name.strip()}'...")
                        try:
                            rename_computer(new_name.strip(), self.log)
                            log_to_dialog("‚úÖ PC renomm√© avec succ√®s")
                            pc_renamed = True
                        except Exception as e:
                            log_to_dialog(f"‚ùå Erreur renommage: {e}")
                    else:
                        log_to_dialog("‚è≠Ô∏è Renommage annul√©")
                
                step_label.configure(text="‚úÖ Configuration termin√©e!")
                log_to_dialog("=" * 50)
                log_to_dialog("‚úÖ AUTO SETUP POSTE STANDARD TERMIN√â!")
                
                # Proposer red√©marrage si PC renomm√©
                if pc_renamed:
                    dialog.update()
                    if messagebox.askyesno("Red√©marrage requis", 
                                          "Le PC a √©t√© renomm√©.\n\nVoulez-vous red√©marrer maintenant ?",
                                          parent=dialog):
                        log_to_dialog("üîÑ Red√©marrage du syst√®me dans 10 secondes...")
                        subprocess.run("shutdown /r /t 10", shell=True)
                        log_to_dialog("‚úÖ Red√©marrage planifi√©")
                    else:
                        log_to_dialog("‚ö†Ô∏è Red√©marrez manuellement pour appliquer le nouveau nom")
            
            elif setup_type == "serveur":
                step_label.configure(text="‚ö†Ô∏è Configuration en attente")
                log_to_dialog("‚ö†Ô∏è Poste Serveur: Configuration en attente de d√©finition")
                log_to_dialog("Aucune action configur√©e pour le moment.")
                progress_bar.set(1.0)
            
            elif setup_type == "veloce":
                # Utiliser les param√®tres pass√©s
                server = server_name
                station = station_number
                
                # Formater le num√©ro de station (01, 02, etc.)
                station_formatted = f"{station:02d}"
                station_no_zero = str(station)
                
                log_to_dialog(f"Serveur: {server}")
                log_to_dialog(f"Num√©ro de station: {station} (format√©: {station_formatted})")
                progress_bar.set(0.1)
                
                # Chemins
                veloce_base = f"\\\\{server}\\veloce"
                station_folder = f"stat{station_formatted}"
                station_path = os.path.join(veloce_base, station_folder, "install")
                install_exe = os.path.join(station_path, f"install (WS{station_formatted}).exe")
                ws_starter = os.path.join(station_path, f"WS Starter{station_no_zero}.exe")
                desktop = os.path.join(os.path.expanduser("~"), "Desktop")
                appdata = os.getenv("APPDATA") or os.path.expanduser("~")
                startup_folder = os.path.join(appdata, "Microsoft", "Windows", "Start Menu", "Programs", "Startup")
                
                # √âtape 1: V√©rifier l'acc√®s au serveur
                step_label.configure(text="V√©rification acc√®s r√©seau...")
                log_to_dialog(f"‚ñ∂ V√©rification acc√®s √† {veloce_base}...")
                
                try:
                    import subprocess
                    ping_result = subprocess.run(
                        f"ping -n 1 -w 1000 {server}",
                        shell=True, capture_output=True, timeout=2
                    )
                    
                    if ping_result.returncode != 0:
                        log_to_dialog(f"‚ùå Serveur {server} non joignable")
                        step_label.configure(text="‚ùå Serveur non joignable")
                        progress_bar.set(1.0)
                        return
                    
                    log_to_dialog(f"‚úì Serveur {server} joignable")
                    
                    if not os.path.exists(station_path):
                        log_to_dialog(f"‚ùå Dossier {station_folder} introuvable")
                        log_to_dialog(f"Chemin: {station_path}")
                        step_label.configure(text="‚ùå Dossier station introuvable")
                        progress_bar.set(1.0)
                        return
                    
                    log_to_dialog(f"‚úì Dossier station accessible: {station_path}")
                    progress_bar.set(0.2)
                    
                except Exception as e:
                    log_to_dialog(f"‚ùå Erreur r√©seau: {e}")
                    step_label.configure(text="‚ùå Erreur r√©seau")
                    progress_bar.set(1.0)
                    return
                
                # √âtape 2: Installer install (WSXX).exe en mode admin
                step_label.configure(text="Installation de l'application...")
                log_to_dialog(f"‚ñ∂ Lancement de install (WS{station_formatted}).exe en mode admin...")
                
                try:
                    if not os.path.exists(install_exe):
                        log_to_dialog(f"‚ùå Fichier introuvable: {install_exe}")
                        step_label.configure(text="‚ùå Fichier install introuvable")
                        progress_bar.set(1.0)
                        return
                    
                    import ctypes
                    # Lancer en mode admin avec le bon r√©pertoire de travail
                    ret = ctypes.windll.shell32.ShellExecuteW(
                        None, "runas", install_exe, None, station_path, 1
                    )
                    
                    if ret > 32:
                        log_to_dialog(f"‚úì install (WS{station_formatted}).exe lanc√© avec succ√®s")
                    else:
                        log_to_dialog(f"‚ùå √âchec du lancement (code: {ret})")
                        step_label.configure(text="‚ùå Erreur installation")
                        progress_bar.set(1.0)
                        return
                    
                    progress_bar.set(0.4)
                    time.sleep(1)
                    
                except Exception as e:
                    log_to_dialog(f"‚ùå Erreur lors de l'installation: {e}")
                    step_label.configure(text="‚ùå Erreur installation")
                    progress_bar.set(1.0)
                    return
                
                # √âtape 3: Cr√©er raccourci sur le bureau
                step_label.configure(text="Cr√©ation du raccourci bureau...")
                log_to_dialog(f"‚ñ∂ Cr√©ation du raccourci 'station {station_no_zero}' sur le bureau...")
                
                try:
                    if not os.path.exists(ws_starter):
                        log_to_dialog(f"‚ùå Fichier source introuvable: {ws_starter}")
                        step_label.configure(text="‚ùå WS Starter introuvable")
                        progress_bar.set(1.0)
                        return
                    
                    # Utiliser PowerShell pour cr√©er le raccourci
                    shortcut_path = os.path.join(desktop, f"station {station_no_zero}.lnk")
                    ps_script = f'''
$WScriptShell = New-Object -ComObject WScript.Shell
$Shortcut = $WScriptShell.CreateShortcut("{shortcut_path}")
$Shortcut.TargetPath = "{ws_starter}"
$Shortcut.WorkingDirectory = "{station_path}"
$Shortcut.Save()
'''
                    ps_cmd = ['powershell', '-ExecutionPolicy', 'Bypass', '-Command', ps_script]
                    result = subprocess.run(ps_cmd, capture_output=True, text=True)
                    
                    if result.returncode == 0 and os.path.exists(shortcut_path):
                        log_to_dialog(f"‚úì Raccourci cr√©√©: {shortcut_path}")
                    else:
                        log_to_dialog(f"‚ùå Erreur cr√©ation raccourci: {result.stderr}")
                        log_to_dialog("‚ö†Ô∏è Continuez manuellement...")
                    
                    progress_bar.set(0.6)
                    
                except Exception as e:
                    log_to_dialog(f"‚ùå Erreur cr√©ation raccourci: {e}")
                    log_to_dialog("‚ö†Ô∏è Continuez manuellement...")
                
                # √âtape 4: Appliquer cl√© de registre
                step_label.configure(text="Application de la cl√© de registre...")
                log_to_dialog("‚ñ∂ Application de la cl√© de registre DirectoryCacheLifetime...")
                
                try:
                    reg_cmd = r'C:\Windows\System32\reg.exe add HKLM\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters /v DirectoryCacheLifetime /t REG_DWORD /d 0 /f'
                    result = subprocess.run(reg_cmd, shell=True, capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        log_to_dialog("‚úì Cl√© de registre appliqu√©e avec succ√®s")
                    else:
                        log_to_dialog(f"‚ùå Erreur registre: {result.stderr}")
                    
                    progress_bar.set(0.8)
                    
                except Exception as e:
                    log_to_dialog(f"‚ùå Erreur cl√© registre: {e}")
                
                # √âtape 5: Copier raccourci dans le d√©marrage
                step_label.configure(text="Configuration du d√©marrage automatique...")
                log_to_dialog("‚ñ∂ Copie du raccourci dans le dossier de d√©marrage...")
                
                try:
                    shortcut_source = os.path.join(desktop, f"station {station_no_zero}.lnk")
                    shortcut_dest = os.path.join(startup_folder, f"station {station_no_zero}.lnk")
                    
                    if os.path.exists(shortcut_source):
                        import shutil
                        shutil.copy2(shortcut_source, shortcut_dest)
                        log_to_dialog(f"‚úì Raccourci copi√© dans D√©marrage")
                    else:
                        log_to_dialog("‚ö†Ô∏è Raccourci source introuvable pour copie")
                    
                    # Supprimer l'ancien raccourci Veloce WS Starter.exe
                    old_shortcut = os.path.join(startup_folder, "Veloce WS Starter.exe")
                    if os.path.exists(old_shortcut):
                        os.remove(old_shortcut)
                        log_to_dialog("‚úì Ancien raccourci 'Veloce WS Starter.exe' supprim√©")
                    
                    progress_bar.set(1.0)
                    step_label.configure(text="‚úÖ Configuration termin√©e!")
                    log_to_dialog("=" * 50)
                    log_to_dialog("‚úÖ STATION VELOCE CONFIGUR√âE AVEC SUCC√àS!")
                    
                except Exception as e:
                    log_to_dialog(f"‚ö†Ô∏è Erreur d√©marrage automatique: {e}")
                    log_to_dialog("Configuration principale termin√©e, v√©rifiez manuellement le d√©marrage")
                    progress_bar.set(1.0)
                    step_label.configure(text="‚úÖ Configuration termin√©e (avec avertissements)")
            
            log_to_dialog("=" * 50)
        
        # Bouton d√©marrer
        def start_setup():
            """D√©marre le setup apr√®s avoir demand√© les param√®tres si n√©cessaire"""
            server = None
            station_num = None
            if setup_type == "veloce":
                # Demander le serveur r√©seau AVANT de lancer le thread
                from tkinter import simpledialog
                server = simpledialog.askstring("Serveur r√©seau", 
                                               "Nom du serveur r√©seau (ex: SV):",
                                               initialvalue="SV",
                                               parent=dialog)
                
                if not server:
                    log_to_dialog("‚ùå Configuration annul√©e")
                    progress_bar.set(1.0)
                    return
                
                # Demander le num√©ro de station
                station_str = simpledialog.askstring("Num√©ro de station", 
                                                     "Num√©ro de la station (ex: 1, 2, 3...):",
                                                     parent=dialog)
                
                if not station_str:
                    log_to_dialog("‚ùå Configuration annul√©e")
                    progress_bar.set(1.0)
                    return
                
                try:
                    station_num = int(station_str)
                    if station_num < 1:
                        raise ValueError("Num√©ro invalide")
                except:
                    log_to_dialog("‚ùå Num√©ro de station invalide")
                    progress_bar.set(1.0)
                    return
            
            # Lancer le worker avec les param√®tres
            threading.Thread(target=lambda: run_worker(server, station_num), daemon=True).start()
        
        ctk.CTkButton(main_frame, text="üöÄ D√©marrer", 
                      command=start_setup,
                      fg_color="#16a34a", hover_color="#15803d").pack(pady=10)
        
        # Bouton fermer
        ctk.CTkButton(main_frame, text="Fermer", 
                      command=dialog.destroy,
                      fg_color="#dc2626", hover_color="#b91c1c").pack(pady=5)


    def build_custom_commands_options(self, parent):
        """Page Commandes personnalis√©es avec support PsExec"""
        f = ctk.CTkScrollableFrame(parent)
        f.pack(fill="both", expand=True, padx=6, pady=6)
        
        ctk.CTkLabel(f, text="Commandes personnalis√©es (Local ou Distant)", 
                     font=ctk.CTkFont(size=16, weight="bold")).pack(anchor="w", pady=(0,10))
        
        # Variables pour les champs
        if not hasattr(self, 'psexec_host_var'):
            self.psexec_host_var = tk.StringVar(value="")
            self.psexec_user_var = tk.StringVar(value="")
            self.psexec_pass_var = tk.StringVar(value="")
            self.psexec_cmd_var = tk.StringVar(value="")
        
        # Champs de saisie
        fields_frame = ctk.CTkFrame(f)
        fields_frame.pack(fill="x", pady=8)
        
        # H√¥te cible (optionnel)
        ctk.CTkLabel(fields_frame, text="H√¥te distant (optionnel):").grid(row=0, column=0, sticky="w", padx=10, pady=5)
        host_entry = ctk.CTkEntry(fields_frame, textvariable=self.psexec_host_var, width=300, 
                                  placeholder_text="Vide = local")
        host_entry.grid(row=0, column=1, padx=10, pady=5)
        
        # Utilisateur (optionnel)
        ctk.CTkLabel(fields_frame, text="Utilisateur distant:").grid(row=1, column=0, sticky="w", padx=10, pady=5)
        ctk.CTkEntry(fields_frame, textvariable=self.psexec_user_var, width=300,
                     placeholder_text="Optionnel").grid(row=1, column=1, padx=10, pady=5)
        
        # Mot de passe (optionnel)
        ctk.CTkLabel(fields_frame, text="Mot de passe distant:").grid(row=2, column=0, sticky="w", padx=10, pady=5)
        ctk.CTkEntry(fields_frame, textvariable=self.psexec_pass_var, width=300, show="*",
                     placeholder_text="Optionnel").grid(row=2, column=1, padx=10, pady=5)
        
        # Commande
        ctk.CTkLabel(fields_frame, text="Commande √† ex√©cuter:").grid(row=3, column=0, sticky="w", padx=10, pady=5)
        ctk.CTkEntry(fields_frame, textvariable=self.psexec_cmd_var, width=400).grid(row=3, column=1, padx=10, pady=5)
        
        # Bouton ex√©cuter
        ctk.CTkButton(f, text="üöÄ Ex√©cuter la commande", width=200,
                      command=self._run_custom_command, 
                      fg_color="#2b6ee6", hover_color="#2058c9").pack(pady=10)
        
        # Commandes rapides
        quick_frame = ctk.CTkFrame(f)
        quick_frame.pack(fill="x", pady=(10,0))
        
        ctk.CTkLabel(quick_frame, text="‚ö° Commandes rapides:",
                     font=ctk.CTkFont(size=13, weight="bold")).pack(anchor="w", padx=10, pady=(10,5))
        
        quick_commands = [
            ("Informations syst√®me", "systeminfo"),
            ("Liste processus", "tasklist"),
            ("Red√©marrer", "shutdown /r /t 0"),
            ("Ouvrir CMD", "cmd.exe"),
        ]
        
        btn_grid = ctk.CTkFrame(quick_frame, fg_color="transparent")
        btn_grid.pack(fill="x", padx=10, pady=5)
        
        for idx, (name, cmd) in enumerate(quick_commands):
            row = idx // 2
            col = idx % 2
            ctk.CTkButton(btn_grid, text=name, width=180,
                          command=lambda c=cmd: self.psexec_cmd_var.set(c)).grid(
                              row=row, column=col, padx=5, pady=5)
        
        # Note importante
        note_frame = ctk.CTkFrame(f, fg_color="#3a3a3a")
        note_frame.pack(fill="x", pady=(10,0), padx=10)
        
        note_text = """
‚ÑπÔ∏è MODE D'EMPLOI:
‚Ä¢ Local: Laisser "H√¥te distant" vide ‚Üí ex√©cution locale
‚Ä¢ Distant: Renseigner IP/nom + credentials ‚Üí ex√©cution via PsExec
  (PsExec doit √™tre dans config/psexec.exe)
  T√©l√©charger: https://learn.microsoft.com/sysinternals/downloads/psexec
"""
        ctk.CTkLabel(note_frame, text=note_text, justify="left",
                     text_color="#a5d6ff", font=ctk.CTkFont(size=11)).pack(padx=15, pady=10)
    
    def _run_custom_command(self):
        """Ex√©cute une commande (locale ou distante via PsExec)"""
        host = self.psexec_host_var.get().strip()
        user = self.psexec_user_var.get().strip()
        password = self.psexec_pass_var.get().strip()
        command = self.psexec_cmd_var.get().strip()
        
        if not command:
            self.log("‚ùå Commande requise")
            return
        
        def worker():
            try:
                # Mode LOCAL (host vide)
                if not host:
                    self.log(f"‚ñ∂ Ex√©cution LOCALE: {command}")
                    result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=60)
                    
                    if result.stdout:
                        self.log("----- SORTIE -----")
                        for line in result.stdout.splitlines():
                            self.log(line)
                    
                    if result.stderr:
                        self.log("----- ERREURS -----")
                        for line in result.stderr.splitlines():
                            self.log(line)
                    
                    self.log(f"‚úÖ Commande locale termin√©e (code: {result.returncode})")
                    return
                
                # Mode DISTANT (avec PsExec)
                base_path = get_base_path()
                psexec_path = os.path.join(base_path, "config", "psexec.exe")
                
                if not os.path.exists(psexec_path):
                    self.log(f"‚ùå PsExec introuvable: {psexec_path}")
                    self.log("üì• T√©l√©chargez PsExec et placez-le dans config/psexec.exe")
                    return
                
                # Construction de la commande PsExec
                cmd_parts = [psexec_path, f"\\\\{host}"]
                if user:
                    cmd_parts.extend(["-u", user])
                if password:
                    cmd_parts.extend(["-p", password])
                
                cmd_parts.extend(["-accepteula", command])
                
                self.log(f"‚ñ∂ Ex√©cution DISTANTE sur {host}: {command}")
                
                result = subprocess.run(cmd_parts, capture_output=True, text=True, timeout=60)
                
                if result.stdout:
                    self.log("----- SORTIE -----")
                    for line in result.stdout.splitlines():
                        self.log(line)
                
                if result.stderr:
                    self.log("----- ERREURS -----")
                    for line in result.stderr.splitlines():
                        self.log(line)
                
                self.log(f"‚úÖ Commande distante termin√©e (code: {result.returncode})")
                
            except subprocess.TimeoutExpired:
                self.log("‚ùå Timeout: La commande a pris trop de temps")
            except Exception as e:
                self.log(f"‚ùå Erreur: {e}")
        
        threading.Thread(target=worker, daemon=True).start()


    def build_ip_config_options(self, parent):
        """Page configuration IP r√©seau compl√®te"""
        f = ctk.CTkScrollableFrame(parent)
        f.pack(fill="both", expand=True, padx=6, pady=6)
        
        ctk.CTkLabel(f, text="Configuration r√©seau - Adresse IP", 
                     font=ctk.CTkFont(size=16, weight="bold")).pack(anchor="w", pady=(0,10))
        
        # Variables
        if not hasattr(self, '_net_iface_var'):
            self._net_iface_var = tk.StringVar(value="")
            self._net_ip_var = tk.StringVar(value="")
            self._net_mask_var = tk.StringVar(value="")
            self._net_gw_var = tk.StringVar(value="")
            self._net_dns1_var = tk.StringVar(value="")
            self._net_dns2_var = tk.StringVar(value="")
            self._net_mode_var = tk.StringVar(value="dhcp")
            self._net_ifaces_info = {}
        
        # Interface s√©lection
        iface_frame = ctk.CTkFrame(f)
        iface_frame.pack(fill="x", pady=8)
        
        ctk.CTkLabel(iface_frame, text="Interface r√©seau:").pack(side="left", padx=(10,8))
        self._iface_menu = ctk.CTkOptionMenu(iface_frame, variable=self._net_iface_var, 
                                              values=[], width=400)
        self._iface_menu.pack(side="left", padx=(0,8))
        
        ctk.CTkButton(iface_frame, text="üîÑ Recharger", width=120,
                      command=lambda: threading.Thread(target=self._detect_interfaces, daemon=True).start()
                      ).pack(side="left")
        
        # Mode DHCP / Statique
        mode_frame = ctk.CTkFrame(f)
        mode_frame.pack(fill="x", pady=8)
        
        ctk.CTkLabel(mode_frame, text="Mode IP:").pack(side="left", padx=(10,8))
        ctk.CTkRadioButton(mode_frame, text="DHCP (Automatique)", 
                          variable=self._net_mode_var, value="dhcp").pack(side="left", padx=6)
        ctk.CTkRadioButton(mode_frame, text="IP Statique", 
                          variable=self._net_mode_var, value="static").pack(side="left", padx=6)
        
        # Champs de configuration
        config_frame = ctk.CTkFrame(f)
        config_frame.pack(fill="both", expand=True, pady=8)
        
        def create_field(parent, label_text, var, row_idx):
            row = ctk.CTkFrame(parent, fg_color="transparent")
            row.pack(fill="x", pady=3)
            ctk.CTkLabel(row, text=label_text, width=200, anchor="w").pack(side="left", padx=10)
            entry = ctk.CTkEntry(row, textvariable=var, width=350)
            entry.pack(side="left", padx=10)
            return entry
        
        self._net_ip_entry = create_field(config_frame, "Adresse IPv4:", self._net_ip_var, 0)
        self._net_mask_entry = create_field(config_frame, "Masque (ex. 255.255.255.0):", self._net_mask_var, 1)
        self._net_gw_entry = create_field(config_frame, "Passerelle par d√©faut:", self._net_gw_var, 2)
        self._net_dns1_entry = create_field(config_frame, "DNS primaire:", self._net_dns1_var, 3)
        self._net_dns2_entry = create_field(config_frame, "DNS secondaire:", self._net_dns2_var, 4)
        
        # Bouton appliquer
        ctk.CTkButton(f, text="‚úÖ Appliquer la configuration", width=250, height=40,
                      fg_color="#2b6ee6", hover_color="#2058c9",
                      command=lambda: threading.Thread(target=self._apply_network_config, daemon=True).start()
                      ).pack(pady=15)
        
        # Activer/D√©sactiver champs selon mode
        def toggle_fields(*args):
            state = "disabled" if self._net_mode_var.get() == "dhcp" else "normal"
            for entry in [self._net_ip_entry, self._net_mask_entry, self._net_gw_entry, 
                         self._net_dns1_entry, self._net_dns2_entry]:
                entry.configure(state=state)
        
        self._net_mode_var.trace_add("write", toggle_fields)
        toggle_fields()
        
        # Remplir les champs quand on change d'interface
        def on_iface_change(iface_name):
            info = self._net_ifaces_info.get(iface_name, {})
            self._net_ip_var.set(info.get("ip", ""))
            self._net_mask_var.set(info.get("mask", ""))
            self._net_gw_var.set(info.get("gw", ""))
            self._net_dns1_var.set(info.get("dns1", ""))
            self._net_dns2_var.set(info.get("dns2", ""))
            self._net_mode_var.set("dhcp" if info.get("dhcp", True) else "static")
        
        self._iface_menu.configure(command=lambda v: on_iface_change(v))
        
        # Lancer la d√©tection au d√©marrage
        threading.Thread(target=self._detect_interfaces, daemon=True).start()
    
    def _detect_interfaces(self):
        """D√©tecte les interfaces r√©seau et r√©cup√®re leurs configs"""
        try:
            self.log("‚ñ∂ D√©tection des interfaces r√©seau...")
            
            # Liste des interfaces via psutil
            interfaces = list(psutil.net_if_addrs().keys())
            infos = {}
            
            for iface in interfaces:
                try:
                    # R√©cup√®re les infos via netsh
                    result = subprocess.check_output(
                        f'netsh interface ip show config name="{iface}"',
                        shell=True, text=True, encoding="utf-8", errors="ignore"
                    )
                    
                    # Parse la sortie
                    info = self._parse_netsh_output(result)
                    dns_list = info.get("dns", [])
                    
                    infos[iface] = {
                        "ip": info.get("ip", ""),
                        "mask": info.get("mask", ""),
                        "gw": info.get("gateway", ""),
                        "dns1": dns_list[0] if len(dns_list) > 0 else "",
                        "dns2": dns_list[1] if len(dns_list) > 1 else "",
                        "dhcp": info.get("dhcp", True)
                    }
                except:
                    infos[iface] = {"ip": "", "mask": "", "gw": "", "dns1": "", "dns2": "", "dhcp": True}
            
            # Mettre √† jour l'UI
            def update_ui():
                self._net_ifaces_info = infos
                names = list(infos.keys())
                
                if names:
                    self._iface_menu.configure(values=names)
                    current = self._net_iface_var.get()
                    selected = current if current in names else names[0]
                    self._net_iface_var.set(selected)
                    
                    # Remplir les champs
                    info = infos[selected]
                    self._net_ip_var.set(info["ip"])
                    self._net_mask_var.set(info["mask"])
                    self._net_gw_var.set(info["gw"])
                    self._net_dns1_var.set(info["dns1"])
                    self._net_dns2_var.set(info["dns2"])
                    self._net_mode_var.set("dhcp" if info["dhcp"] else "static")
                else:
                    self._iface_menu.configure(values=["Aucune interface"])
                    self._net_iface_var.set("")
                
                self.log(f"‚úÖ {len(names)} interface(s) d√©tect√©e(s)")
            
            self.after(0, update_ui)
            
        except Exception as e:
            self.log(f"‚ùå Erreur d√©tection interfaces: {e}")
    
    def _parse_netsh_output(self, output):
        """Parse la sortie de netsh pour extraire les infos r√©seau"""
        info = {"ip": "", "mask": "", "gateway": "", "dns": [], "dhcp": False}
        
        # D√©tecter DHCP globalement d'abord
        if re.search(r"DHCP\s+(?:activ√©|enabled)\s*:\s*(?:Oui|Yes)", output, re.IGNORECASE | re.MULTILINE):
            info["dhcp"] = True
        elif re.search(r"DHCP\s+(?:activ√©|enabled)\s*:\s*(?:Non|No)", output, re.IGNORECASE | re.MULTILINE):
            info["dhcp"] = False
        
        lines = output.splitlines()
        
        for i, line in enumerate(lines):
            line_lower = line.lower().strip()
            
            # IP Address - cherche plusieurs patterns
            if any(x in line_lower for x in ["adresse ip", "ip address"]):
                # Sur la m√™me ligne
                m = re.search(r":\s*([\d\.]+)", line)
                if m and m.group(1) != "0.0.0.0":
                    info["ip"] = m.group(1)
                # Ligne suivante
                elif i + 1 < len(lines):
                    m = re.search(r"([\d\.]+)", lines[i + 1])
                    if m and m.group(1) != "0.0.0.0":
                        info["ip"] = m.group(1)
            
            # Subnet Mask - cherche plusieurs patterns
            if any(x in line_lower for x in ["masque de sous", "subnet mask", "subnet prefix"]):
                # Format direct 255.255.255.0
                m = re.search(r":\s*([\d\.]+)", line)
                if m:
                    info["mask"] = m.group(1)
                # Format CIDR /24
                elif "/" in line:
                    m = re.search(r"/(\d+)", line)
                    if m:
                        prefix = int(m.group(1))
                        mask_bits = '1' * prefix + '0' * (32 - prefix)
                        octets = [str(int(mask_bits[i:i+8], 2)) for i in range(0, 32, 8)]
                        info["mask"] = '.'.join(octets)
                # Ligne suivante
                elif i + 1 < len(lines):
                    m = re.search(r"([\d\.]+)", lines[i + 1])
                    if m:
                        info["mask"] = m.group(1)
            
            # Gateway - cherche plusieurs patterns
            if any(x in line_lower for x in ["passerelle", "gateway", "default gateway"]):
                # Sur la m√™me ligne
                m = re.search(r":\s*([\d\.]+)", line)
                if m and m.group(1) not in ["0.0.0.0", ""]:
                    info["gateway"] = m.group(1)
                # Ligne suivante
                elif i + 1 < len(lines):
                    m = re.search(r"([\d\.]+)", lines[i + 1])
                    if m and m.group(1) not in ["0.0.0.0", ""]:
                        info["gateway"] = m.group(1)
            
            # DNS Servers
            if any(x in line_lower for x in ["serveur dns", "dns server"]):
                # Sur la m√™me ligne
                m = re.search(r":\s*([\d\.]+)", line)
                if m:
                    info["dns"].append(m.group(1))
                # Lignes suivantes (DNS multiples)
                j = i + 1
                while j < len(lines) and j < i + 5:
                    m = re.search(r"^\s*([\d\.]+)\s*$", lines[j].strip())
                    if m:
                        info["dns"].append(m.group(1))
                        j += 1
                    else:
                        break
        
        return info
    
    def _apply_network_config(self):
        """Applique la configuration r√©seau"""
        iface = self._net_iface_var.get()
        if not iface:
            self.log("‚ùå Aucune interface s√©lectionn√©e")
            return
        
        if not is_admin():
            self.log("üîº Droits administrateur requis, relance...")
            try:
                relaunch_as_admin()
            except Exception as e:
                self.log(f"‚ùå Impossible de relancer en admin: {e}")
            return
        
        mode = self._net_mode_var.get()
        self.log(f"‚ñ∂ Application de la configuration sur '{iface}' (mode: {mode})")
        
        try:
            if mode == "dhcp":
                subprocess.run(f'netsh interface ip set address name="{iface}" source=dhcp', shell=True, check=True)
                subprocess.run(f'netsh interface ip set dns name="{iface}" source=dhcp', shell=True, check=True)
                self.log("‚úÖ Interface configur√©e en DHCP")
            else:
                ip = self._net_ip_var.get().strip()
                mask = self._net_mask_var.get().strip()
                gw = self._net_gw_var.get().strip()
                dns1 = self._net_dns1_var.get().strip()
                dns2 = self._net_dns2_var.get().strip()
                
                if not ip or not mask:
                    self.log("‚ùå IP et masque requis pour IP statique")
                    return
                
                subprocess.run(f'netsh interface ip set address name="{iface}" static {ip} {mask} {gw}', 
                              shell=True, check=True)
                self.log(f"‚úÖ IP statique: {ip}/{mask}, GW: {gw or 'aucune'}")
                
                if dns1:
                    subprocess.run(f'netsh interface ip set dns name="{iface}" static {dns1}', 
                                  shell=True, check=True)
                    self.log(f"‚úÖ DNS primaire: {dns1}")
                
                if dns2:
                    subprocess.run(f'netsh interface ip add dns name="{iface}" {dns2}', 
                                  shell=True, check=True)
                    self.log(f"‚úÖ DNS secondaire: {dns2}")
            
            time.sleep(1)
            self.log("üîÑ Actualisation des informations...")
            self._detect_interfaces()
            
        except Exception as e:
            self.log(f"‚ùå Erreur: {e}")

